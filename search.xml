<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【学习笔记】KMP 算法学习笔记</title>
      <link href="/2020/06/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91KMP-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/06/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91KMP-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>发现自己不会 KMP 的模板了，借此机会复习一下 KMP，顺便更深入地研究前缀函数 $\pi$ 的应用。</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>为了更方便地描述字符串相关内容，我们做出以下规定：</p><ol><li>$S, T$ 通常表示一个字符串，$c$ 通常表示一个字符，$\Sigma$ 表示字符集；</li><li>$\left|S\right|$ 表示字符串长度；</li><li>$\left|\Sigma\right|$ 表示字符集大小；</li><li>$S[l..r]$ 表示 $S[l], S[l + 1], \ldots, S[r - 1], S[r]$；</li><li>$\epsilon$ 表示空串；</li><li>$S$ 是 $T$ 的前缀，用 $S \sqsubset T$ 表示；$S$ 是 $T$ 的后缀，用 $S \sqsupset T$ 表示；</li><li>$S_i$ 表示 $S[1..i]$，即 $S$ 的第 $i$ 个前缀。</li></ol><p>特殊地，本文的字符串下标、$\pi$ 数组下标 <strong>均从 $1$ 开始</strong>。</p><blockquote><p>一些例子：对于 $S = \mathtt{ABCBAD}$ 而言：</p><ol><li>$\left|S\right| = 6$；</li><li>$\left|\Sigma\right| = 4$；</li><li>$S[2..4] = \mathtt{BCBA}$；</li><li>$S_4 = \mathtt{ABCB}$。</li></ol></blockquote><h3 id="前缀函数数组"><a href="#前缀函数数组" class="headerlink" title="前缀函数数组"></a>前缀函数数组</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对于一个字符串 $S$，我们定义其前缀函数 $\pi(S)$ 的值为 $S$ 的最长相等的真前缀和真后缀的长度，即：<br>$$<br>\begin{aligned}<br>\pi(S) &amp; = \mathop{\operatorname{argmax}}\limits_{k &lt; \left|S\right|}\{S[1..k] = S[\left|S\right| - k + 1..\left|S\right|]\}<br>\\<br>&amp; = \mathop{\operatorname{argmax}}\limits_{k &lt; \left|S\right|}\{S_k \sqsupset S\}<br>\end{aligned}<br>$$<br>对于一个字符串 $S$，我们定义其前缀函数数组 $\pi$ 为 $\pi[i] = \pi(S_i)$。</p><blockquote><p>特殊地，当 $\left|S\right| = 1$ 时 $\pi(S) = \mathop{\operatorname{argmax}}\limits_{k &lt; 1}\{S[1..k] = S[2 - k..1]\}$</p><p>当 $k = 0$ 时 $S[1..0] = S[2..1] = \epsilon$，故 $\pi(S) = 0$。</p></blockquote><hr><blockquote><p>性质 1：$\pi(S_i) = \pi[i] &lt; i$。</p></blockquote><div class='spoiler collapsed'>    <div class='spoiler-title'>        证明    </div>    <div class='spoiler-content'>        <p>由定义知 $\pi[i] &lt; i$，即得证。</p><p align="right">$\blacksquare$ </p>    </div></div><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ol><li><p>根据定义，$\pi[1] = 0$；</p></li><li><p>假设我们循环到了要求 $\pi[i]\quad(i \ge 2)$，令 $k \gets \pi[i - 1]$。</p><p>由 $\pi$ 数组的定义得，此时 $S[1..k] = S[i - k, i - 1]$。</p><p>我们现在要做的，就是从 $\pi[1..i - 1]$ 递推到 $\pi[i]$：</p><p>考虑到 $\pi$ 数组的定义，我们不断地枚举共同的前后缀（即使用 $k = \pi[k]$ 来迭代）。</p><p>结束这个迭代，有且仅有两种情况：$k = 0$ 或 $S[k + 1] = S[i]$。</p><hr><p>对于前者，说明对于字符串 $S[1..i]$，不存在任何两个真前缀与真后缀相同，$\pi[i] = 0$。</p><p>对于后者，说明我们找到了一个 $k$，使得 $S[1..k + 1] = S[i - k..i]$，根据定义，有 $\pi[i] = k + 1$。</p></li><li><p>至此，我们求出了字符串 $S$ 的前缀函数数组 $\pi$。</p></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="cpp">void calcPi(char* S) {    pi[1] = 0;    int len = strlen(S + 1);    for(int i = 2, k = 0; i &lt;= len; ++i) {        while(k &gt; 0 &amp;&amp; S[k + 1] != T[i])            k = pi[k];           if(S[k + 1] == S[i])            ++k;           pi[i] = k;    }}</code></pre><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><blockquote><p>引理 1（后缀重叠引理）：对于 $x, y$ 满足 $x \sqsupset z, y \sqsupset z$ 而言，若 $\left|x\right| \le \left|y\right|$，则 $x \sqsupset y$；若 $\left|x\right| \ge \left|y\right|$，则 $y \sqsupset x$；若 $\left|x\right| = \left|y\right|$，则 $x = y$。</p></blockquote><p>过于显然，证明略。</p><p align="right">$\blacksquare$ </p><hr><p>设<br>$$<br>\pi^{\star}[q] = \{\pi[q], \pi^{(2)}[q], \cdots, \pi^{(t)}[q]\}<br>$$<br>其中<br>$$<br>\pi^{(i)}[q] = \begin{cases}q &amp; i = 0 \\ \pi[\pi^{(i - 1)}[q]] &amp; i \ge 1\end{cases}<br>$$</p><p>当 $\pi^{(t)}[q] = 0$ 时 $\pi^{\star}[q]$ 中的序列终止。</p><blockquote><p>引理 2（前缀函数迭代引理）：对任意长度为 $n$ 的字符串 $S$，有 $\forall q \in [1, n], \pi^{\star}[q] = \{k: k &lt; q \land S_k \sqsupset S_q\}$。</p></blockquote><div class='spoiler collapsed'>    <div class='spoiler-title'>        证明    </div>    <div class='spoiler-content'>        <ul><li><p>先证明 $\pi^{\star}[q] \subseteq \{k:k &lt; q \land S_k \sqsupset S_q\}$，</p><p>即证明 $\forall x \in \pi^{\star}[q], x &lt; q \land S_x \sqsupset S_q$。</p><p>任取 $x \in \pi^{\star}[q]$，不妨设 $x = \pi^{u}[q] \quad (u &gt; 0)$，下面通过对 $u$ 的数学归纳法证明命题成立。</p><p>（基础）当 $u = 1$ 时，$x = \pi[q]$，由 $\pi$ 数组的定义可知 $\pi[q] &lt; q \land S_{\pi[q]} \sqsupset S_q$。</p><p>（假设）假设当 $u = v$ 时 $\pi^{v}[q] &lt; q \land S_{\pi^{v}[q]} \sqsupset S_q$。</p><p>（推导）则当 $u = v + 1$ 时，$\pi^{v + 1}[q] = \pi[\pi^{v}[q]] &lt; \pi^{v}[q] &lt; q$（性质 1）；$S_{\pi^{v + 1}[q]} \sqsupset S_{\pi^{v}[q]} \sqsupset S_q$（由性质 1 得到下标的大小关系，由引理 1 得到前缀之间的关系）</p><p>因此 $\forall x \in \pi^{\star}[q], x &lt; q \land S_x \sqsupset S_q$。</p></li><li><p>再证明 $\{k:k &lt; q \land S_k \sqsupset S_q\} \subseteq \pi^{\star}[q]$，</p><p>即证明 $\forall x \in \{k:k &lt; q \land S_x \sqsupset S_q\}, x \in\pi^{\star}[q]$</p><p>考虑使用反证法来证明命题成立。</p><p>假设集合 $M = \{k:k &lt; q \land S_k \sqsupset S_q\} - \pi^{\star}[q]$ 非空，$j$ 是 $M$ 中的最大值。</p><p>$\because$ $\pi[q]$ 是 $\{k:k &lt; q \land S_x \sqsupset S_q\}$ 中的最大值，且 $j \in \{k:k &lt; q \land S_x \sqsupset S_q\}$</p><p>$\therefore j &lt; \pi[q], S_j \sqsupset S_q$</p><p>又 $\because \pi[q] \in \pi^{\star}[q]$</p><p>$\therefore \exists j’ \in \pi^{\star}[q], \text{s.t. }j’ &gt; j$</p><p>设 $j’$ 表示 $\pi^{\star}[q]$ 中比 $j$ 大的最小整数。</p><p>$\because \{k:k &lt; q \land S_k \sqsupset S_q\} \subseteq \pi^{\star}[q]$ 且 $j’ \in \pi^{\star}[q]$</p><p>$\therefore S_{j’} \sqsupset S_q$</p><p>$\because j’ &gt; j$ 且 $j$ 是小于 $j’$ 的最大值</p><p>$\therefore S_j \sqsupset S_{j’}$（引理 1）</p><p>由 $\pi$ 数组的定义知 $\pi[j’] = j$</p><p>$\because j’ \in \pi^{\star}[q]$</p><p>$\therefore j = \pi[j’] \in \pi^{\star}[q]$，与假设矛盾</p><p>因此 $\{k:k &lt; q \land S_k \sqsupset S_q\} \subseteq \pi^{\star}[q]$。</p><p>综上所述，对任意长度为 $n$ 的字符串 $S$，有 $\forall q \in [1, n], \pi^{\star}[q] = \{k: k &lt; q \land S_k \sqsupset S_q\}$。</p><p align="right">$\blacksquare$ </p></li></ul>    </div></div><hr><blockquote><p>引理 3：对任意长度为 $n$ 的字符串 $S$，有 $\forall q \in [1, n]$，若 $\pi[q] &gt; 0$，则 $\pi[q] - 1 \in \pi^{\star}[q - 1]$。</p></blockquote><div class='spoiler collapsed'>    <div class='spoiler-title'>        证明    </div>    <div class='spoiler-content'>        <p>令 $x = \pi[q] &gt; 0$，则 $x &lt; q, S_x \sqsupset S_q$</p><p>$\because x &gt; 0$，则 $x - 1$ 有意义</p><p>$\therefore x - 1 &lt; q - 1, S_{x - 1} \sqsupset S_{q - 1}$（把 $S_x$ 和 $S_q$ 的最后一个字符去掉） </p><p>由引理 2 知 $x - 1 \in \pi^{\star}[q - 1]$</p><p>$\therefore \forall q \in [1, n] \land \pi[q] &gt; 0,\pi[q] - 1 \in \pi^{\star}[q - 1]$</p><p align="right">$\blacksquare$ </p>    </div></div><hr><p>对 $q \in [2, n]$ 定义子集 $E_{q - i} \subseteq \pi^{\star}[q - 1]$ 为：</p><p>$$<br>E_{q - 1} = \{k\in\pi^{\star}[q - 1]:S_{k + 1} = S_k\}<br>$$</p><p>则有：</p><p>$$<br>\begin{aligned}<br> E_{q - 1} &amp; = \{k\in\pi^{\star}[q - 1]:S_{k + 1} = S_k\}<br> \\<br> &amp; = \{k: k &lt; q - 1, S_k \sqsupset S_{q - 1}, S[k + 1] = S[q]\}<br> \\<br> &amp; = \{k: k &lt; q - 1, S_{k + 1} \sqsupset S_q\}<br>\end{aligned}<br>$$</p><p>因此，$E_{q - 1}$ 是由 $\pi^{\star}[q - 1]$ 中的值组成的、能满足 $S_{k + 1}$ 与 $S_q$ 的某个后缀相等的 $k$ 组成的集合。</p><blockquote><p>推论 1：对任意长度为 $n$ 的字符串 $S$，有<br>$$<br>\forall q \in [2, n],\pi[q] = \begin{cases}0 &amp; E_{q - 1} = \varnothing \\ 1 + \max\{k \in E_{q - 1}\} &amp; E_{q - 1} \neq \varnothing\end{cases}<br>$$</p></blockquote><div class='spoiler collapsed'>    <div class='spoiler-title'>        证明    </div>    <div class='spoiler-content'>        <ul><li><p>当 $E_{q - 1} = \varnothing$ 时，不存在任何一个 $k \in \pi^{\star}[q - 1]$，使得 $S_{k + 1} \sqsupset S_q$。</p><p>显然此时 $\pi[q]$ 只能为 $0$。</p></li><li><p>当 $E_{q - 1} \neq \varnothing$ 时，</p><ul><li><p>$\forall k \in E_{q - 1}, k &lt; q - 1 \land S_{k + 1} \sqsupset S_q \Longrightarrow k + 1 &lt; q$</p><p>则由 $\pi[q]$ 的定义，$k$ 是拓展到 $S_q$ 的某一后缀的备选项，$\pi[q] \ge 1 + \max\{k \in E_{q - 1}\}$。</p></li><li><p>注意到此时 $\pi[q] &gt; 0$，设 $r = \pi[q] - 1$。</p><p>则 $r + 1 = \pi[q] &lt; q, S_{r + 1} = S_{\pi[q]} \sqsupset S_q$。</p><p>$\because r + 1 &gt; 0$</p><p>$\therefore S_{r + 1} = S_q$</p><p>由引理 3 可得 $r = \pi[q] - 1 \in \pi^{\star}[q - 1]$</p><p>$\therefore r \in E_{q - 1}$</p><p>$\therefore \pi[q] - 1 = r \le \max\{k \in E_{q - 1}\}$</p><p>即 $\pi[q] \le 1 + \max\{k \in E_{q - 1}\}$</p></li></ul><p>综上所述，当 $E_{q - 1} \neq \varnothing$，$\pi[q] = 1 + \max\{k \in E_{q - 1}\}$。</p></li></ul><p align="right">$\blacksquare$ </p>    </div></div><hr><p>再来看看代码：</p><pre><code class="cpp">void calcPi(char* S) {    pi[1] = 0;    int len = strlen(S + 1);    for(int i = 2, k = 0; i &lt;= len; ++i) {        while(k &gt; 0 &amp;&amp; S[k + 1] != S[i])            k = pi[k];           if(S[k + 1] == S[i])            ++k;           pi[i] = k;    }}</code></pre><p>接下来我们将使用循环不变式来证明上述代码的正确性。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        证明    </div>    <div class='spoiler-content'>        <ul><li><p>初始化</p><p>在第 4 行的迭代开始前，有 $i = 1, k = \pi[i] = 0$，不变式成立。</p></li><li><p>保持</p><p>在每次迭代开始前，有 $k = \pi[i - 1]$：</p><ul><li>若是第一次迭代，此等式由第 4 行保证；</li><li>其余迭代均由第 9 行保证。</li></ul><p>接下来要证明每次迭代结束后均有 $k = \pi[i]$ 成立。</p><p>若 $k \neq \pi[i]$，则会在第 5-8 行将 $k$ 调整至 $\pi[i]$。</p><ul><li>第 5 行的 <code>while</code> 循环遍历每一个 $k \in \pi^{\star}[i - 1]$，直至找到一个 $k$，使得 $S[k + 1] = S[i]$。（引理 2）<ul><li>若找不到这样的值，则在第 7 行 $k = 0$。</li><li>若找到了这样的值，此时 $k$ 为满足条件的集合中的最大值，应将 $\pi[i] \gets k + 1$。（推论 1）</li></ul></li></ul><p>第 9 行的赋值语句使得 $k = \pi[i]$ 恒成立。</p></li><li><p>终止</p><p>当 $i = n + 1$ 时，迭代终止，此时我们求出了 $\pi[1..n]$。</p><p>至此，算法结束。</p></li></ul><p>因此，上述代码实现能正确地求出字符串 $S$ 的前缀函数数组。</p><p align="right">$\blacksquare$ </p>    </div></div><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>不难发现，第 7-9 行代码的时间复杂度均为 $O(n)$，唯一棘手的是第 6-7 行代码。</p><p>考虑 $k$ 的变化，$k$ 在第 7-8 行增加的次数不超过 $n$ 次，即 $k \le n$；</p><p>$k$ 在第 6 行的操作中，因为有 $\pi(S_i) &lt; i$ 的性质，导致每次迭代至少使 $k$ 减小 $1$，即最多迭代 $n$ 次。</p><p>综上所述，用上述方法求一个字符串的前缀函数数组的时间复杂度为 $O(n)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>易知用此种方法求前缀函数数组的空间复杂度为 $O(n)$。</p><h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><h4 id="正确性-1"><a href="#正确性-1" class="headerlink" title="正确性"></a>正确性</h4><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 前缀函数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
