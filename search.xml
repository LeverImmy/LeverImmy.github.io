<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【学习笔记】KMP 算法学习笔记</title>
      <link href="/2020/06/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91KMP-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/06/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91KMP-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>发现自己不会 KMP 的模板了，借此机会复习一下 KMP，顺便更深入地研究前缀函数 $\pi$ 的应用。</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>为了更方便地描述字符串相关内容，我们做出以下规定：</p><ol><li>字符串通常用 $S, T$ 等表示，$c$ 通常表示一个字符，$\Sigma$ 表示字符集；</li><li>字符串长度用 $\left|S\right|$ 表示；</li><li>字符集大小用 $\left|\Sigma\right|$ 表示；</li><li>$S[l..r]$ 表示 $S[l], S[l + 1], \ldots, S[r - 1], S[r]$；</li><li>空串用 $\epsilon$ 表示；</li><li>$S$ 是 $T$ 的前缀，用 $S \sqsubset T$ 表示；$S$ 是 $T$ 的后缀，用 $S \sqsupset T$ 表示；</li><li>$S$ 的第 $i$ 个前缀，即 $S[1..i]$，用 $S_i$ 表示。</li></ol><p>特殊地，本文的字符串下标、$\pi$ 数组下标 <strong>均从 $1$ 开始</strong>。</p><blockquote><p>一些例子：对于 $S = \mathtt{ABCBAD}$ 而言：</p><ol><li>$\left|S\right| = 6$；</li><li>$\left|\Sigma\right| = 4$；</li><li>$S[2..4] = \mathtt{BCBA}$；</li><li>$S_4 = \mathtt{ABCB}$。</li></ol></blockquote><h3 id="前缀函数数组"><a href="#前缀函数数组" class="headerlink" title="前缀函数数组"></a>前缀函数数组</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对于一个字符串 $S$，我们定义其前缀函数 $\pi(S)$ 的值为 $S$ 的最长相等的真前缀和真后缀的长度，即：<br>$$<br>\begin{aligned}<br>\pi(S) &amp; = \mathop{\operatorname{argmax}}\limits_{k &lt; \left|S\right|}\{S[1..k] = S[\left|S\right| - k + 1..\left|S\right|]\}<br>\\<br>&amp; = \mathop{\operatorname{argmax}}\limits_{k &lt; \left|S\right|}\{S_k \sqsupset S\}<br>\end{aligned}<br>$$<br>对于一个字符串 $S$，我们定义其前缀函数数组 $\pi$ 为 $\pi[i] = \pi(S_i)$。</p><div class="note warning">            <p>特殊地，当 $\left|S\right| = 1$ 时 $\pi(S) = \mathop{\operatorname{argmax}}\limits_{k &lt; 1}\{S[1..k] = S[2 - k..1]\}$</p><p>当 $k = 0$ 时 $S[1..0] = S[2..1] = \epsilon$，故 $\pi(S) = 0$。</p>          </div><div class="note success">            <p>性质 1：$\pi(S_i) = \pi[i] &lt; i$。</p>          </div><details ><summary> <p>证明</p> </summary>              <div class='content'>              <p>由定义知 $\pi[i] &lt; i$，即得证。</p><p align="right">$\blacksquare$ </p>              </div>            </details><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ol><li><p>根据定义，$\pi[1] = 0$；</p></li><li><p>假设我们循环到了要求 $\pi[i]\quad(i \ge 2)$，令 $k \gets \pi[i - 1]$。</p><p>由 $\pi$ 数组的定义得，此时 $S[1..k] = S[i - k, i - 1]$。</p><p>我们现在要做的，就是从 $\pi[1..i - 1]$ 递推到 $\pi[i]$：</p><p>考虑到 $\pi$ 数组的定义，我们不断地枚举共同的前后缀（即使用 $k = \pi[k]$ 来迭代）。</p><p>结束这个迭代，有且仅有两种情况：$k = 0$ 或 $S[k + 1] = S[i]$。</p><hr><p>对于前者，说明对于字符串 $S[1..i]$，不存在任何两个真前缀与真后缀相同，$\pi[i] = 0$。</p><p>对于后者，说明我们找到了一个 $k$，使得 $S[1..k + 1] = S[i - k..i]$，根据定义，有 $\pi[i] = k + 1$。</p></li><li><p>至此，我们求出了字符串 $S$ 的前缀函数数组 $\pi$。</p></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcPi</span><span class="params">(<span class="keyword">char</span>* S)</span> </span>&#123;</span><br><span class="line">    pi[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, k = <span class="number">0</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; S[k + <span class="number">1</span>] != T[i])</span><br><span class="line">            k = pi[k];</span><br><span class="line">       <span class="keyword">if</span>(S[k + <span class="number">1</span>] == S[i])</span><br><span class="line">            ++k;</span><br><span class="line">       pi[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><div class="note success">            <p>引理 1（后缀重叠引理）：对于 $x, y$ 满足 $x \sqsupset z, y \sqsupset z$ 而言，有</p><ul><li>若 $\left|x\right| \le \left|y\right|$，则 $x \sqsupset y$；</li><li>若 $\left|x\right| \ge \left|y\right|$，则 $y \sqsupset x$；</li><li>若 $\left|x\right| = \left|y\right|$，则 $x = y$。</li></ul>          </div><details ><summary> <p>证明</p> </summary>              <div class='content'>              <p>过于显然，证明略。</p><p align="right">$\blacksquare$ </p>              </div>            </details><p>设<br>$$<br>\pi^{\star}[q] = \{\pi[q], \pi^{(2)}[q], \cdots, \pi^{(t)}[q]\}<br>$$<br>其中<br>$$<br>\pi^{(i)}[q] = \begin{cases}q &amp; i = 0 \\ \pi[\pi^{(i - 1)}[q]] &amp; i \ge 1\end{cases}<br>$$</p><p>当 $\pi^{(t)}[q] = 0$ 时 $\pi^{\star}[q]$ 中的序列终止。</p><div class="note success">            <p>引理 2（前缀函数迭代引理）：对任意长度为 $n$ 的字符串 $S$，有<br>$$<br>\forall q \in [1, n], \pi^{\star}[q] = \{k: k &lt; q \land S_k \sqsupset S_q\}<br>$$</p>          </div><details ><summary> <p>证明</p> </summary>              <div class='content'>              <ul><li><p>先证明 $\pi^{\star}[q] \subseteq \{k:k &lt; q \land S_k \sqsupset S_q\}$，</p><p>即证明 $\forall x \in \pi^{\star}[q], x &lt; q \land S_x \sqsupset S_q$。</p><p>任取 $x \in \pi^{\star}[q]$，不妨设 $x = \pi^{u}[q] \quad (u &gt; 0)$，下面通过对 $u$ 的数学归纳法证明命题成立。</p><p>（基础）当 $u = 1$ 时，$x = \pi[q]$，由 $\pi$ 数组的定义可知 $\pi[q] &lt; q \land S_{\pi[q]} \sqsupset S_q$。</p><p>（假设）假设当 $u = v$ 时 $\pi^{v}[q] &lt; q \land S_{\pi^{v}[q]} \sqsupset S_q$。</p><p>（推导）则当 $u = v + 1$ 时，$\pi^{v + 1}[q] = \pi[\pi^{v}[q]] &lt; \pi^{v}[q] &lt; q$（性质 1）；$S_{\pi^{v + 1}[q]} \sqsupset S_{\pi^{v}[q]} \sqsupset S_q$（由性质 1 得到下标的大小关系，由引理 1 得到前缀之间的关系）</p><p>因此 $\forall x \in \pi^{\star}[q], x &lt; q \land S_x \sqsupset S_q$。</p></li><li><p>再证明 $\{k:k &lt; q \land S_k \sqsupset S_q\} \subseteq \pi^{\star}[q]$，</p><p>即证明 $\forall x \in \{k:k &lt; q \land S_x \sqsupset S_q\}, x \in\pi^{\star}[q]$</p><p>考虑使用反证法来证明命题成立。</p><p>假设集合 $M = \{k:k &lt; q \land S_k \sqsupset S_q\} - \pi^{\star}[q]$ 非空，$j$ 是 $M$ 中的最大值。</p><p>$\because$ $\pi[q]$ 是 $\{k:k &lt; q \land S_x \sqsupset S_q\}$ 中的最大值，且 $j \in \{k:k &lt; q \land S_x \sqsupset S_q\}$</p><p>$\therefore j &lt; \pi[q], S_j \sqsupset S_q$</p><p>又 $\because \pi[q] \in \pi^{\star}[q]$</p><p>$\therefore \exists j’ \in \pi^{\star}[q], \text{s.t. }j’ &gt; j$</p><p>设 $j’$ 表示 $\pi^{\star}[q]$ 中比 $j$ 大的最小整数。</p><p>$\because \{k:k &lt; q \land S_k \sqsupset S_q\} \subseteq \pi^{\star}[q]$ 且 $j’ \in \pi^{\star}[q]$</p><p>$\therefore S_{j’} \sqsupset S_q$</p><p>$\because j’ &gt; j$ 且 $j$ 是小于 $j’$ 的最大值</p><p>$\therefore S_j \sqsupset S_{j’}$（引理 1）</p><p>由 $\pi$ 数组的定义知 $\pi[j’] = j$</p><p>$\because j’ \in \pi^{\star}[q]$</p><p>$\therefore j = \pi[j’] \in \pi^{\star}[q]$，与假设矛盾</p><p>因此 $\{k:k &lt; q \land S_k \sqsupset S_q\} \subseteq \pi^{\star}[q]$。</p><p>综上所述，对任意长度为 $n$ 的字符串 $S$，有 $\forall q \in [1, n], \pi^{\star}[q] = \{k: k &lt; q \land S_k \sqsupset S_q\}$。</p><p align="right">$\blacksquare$ </p>              </div>            </details></li></ul><div class="note success">            <p>引理 3：对任意长度为 $n$ 的字符串 $S$，有 $\forall q \in [1, n]$，若 $\pi[q] &gt; 0$，则 $\pi[q] - 1 \in \pi^{\star}[q - 1]$。</p>          </div><details ><summary> <p>证明</p> </summary>              <div class='content'>              <p>令 $x = \pi[q] &gt; 0$，则 $x &lt; q, S_x \sqsupset S_q$</p><p>$\because x &gt; 0$，则 $x - 1$ 有意义</p><p>$\therefore x - 1 &lt; q - 1, S_{x - 1} \sqsupset S_{q - 1}$（把 $S_x$ 和 $S_q$ 的最后一个字符去掉） </p><p>由引理 2 知 $x - 1 \in \pi^{\star}[q - 1]$</p><p>$\therefore \forall q \in [1, n] \land \pi[q] &gt; 0,\pi[q] - 1 \in \pi^{\star}[q - 1]$</p><p align="right">$\blacksquare$ </p>              </div>            </details><hr><p>对 $q \in [2, n]$ 定义子集 $E_{q - i} \subseteq \pi^{\star}[q - 1]$ 为：</p><p>$$<br>E_{q - 1} = \{k\in\pi^{\star}[q - 1]:S_{k + 1} = S_k\}<br>$$</p><p>则有：</p><p>$$<br>\begin{aligned}<br> E_{q - 1} &amp; = \{k\in\pi^{\star}[q - 1]:S_{k + 1} = S_k\}<br> \\<br> &amp; = \{k: k &lt; q - 1, S_k \sqsupset S_{q - 1}, S[k + 1] = S[q]\}<br> \\<br> &amp; = \{k: k &lt; q - 1, S_{k + 1} \sqsupset S_q\}<br>\end{aligned}<br>$$</p><p>因此，$E_{q - 1}$ 是由 $\pi^{\star}[q - 1]$ 中的值组成的、能满足 $S_{k + 1}$ 与 $S_q$ 的某个后缀相等的 $k$ 组成的集合。</p><div class="note success">            <p>推论 1：对任意长度为 $n$ 的字符串 $S$，有<br>$$<br>\forall q \in [2, n],\pi[q] = \begin{cases}0 &amp; E_{q - 1} = \varnothing \\ 1 + \max\{k \in E_{q - 1}\} &amp; E_{q - 1} \neq \varnothing\end{cases}<br>$$</p>          </div><details ><summary> <p>证明</p> </summary>              <div class='content'>              <ul><li><p>当 $E_{q - 1} = \varnothing$ 时，不存在任何一个 $k \in \pi^{\star}[q - 1]$，使得 $S_{k + 1} \sqsupset S_q$。</p><p>显然此时 $\pi[q]$ 只能为 $0$。</p></li><li><p>当 $E_{q - 1} \neq \varnothing$ 时，</p><ul><li><p>$\forall k \in E_{q - 1}, k &lt; q - 1 \land S_{k + 1} \sqsupset S_q \Longrightarrow k + 1 &lt; q$</p><p>则由 $\pi[q]$ 的定义，$k$ 是拓展到 $S_q$ 的某一后缀的备选项，$\pi[q] \ge 1 + \max\{k \in E_{q - 1}\}$。</p></li><li><p>注意到此时 $\pi[q] &gt; 0$，设 $r = \pi[q] - 1$。</p><p>则 $r + 1 = \pi[q] &lt; q, S_{r + 1} = S_{\pi[q]} \sqsupset S_q$。</p><p>$\because r + 1 &gt; 0$</p><p>$\therefore S_{r + 1} = S_q$</p><p>由引理 3 可得 $r = \pi[q] - 1 \in \pi^{\star}[q - 1]$</p><p>$\therefore r \in E_{q - 1}$</p><p>$\therefore \pi[q] - 1 = r \le \max\{k \in E_{q - 1}\}$</p><p>即 $\pi[q] \le 1 + \max\{k \in E_{q - 1}\}$</p></li></ul><p>综上所述，当 $E_{q - 1} \neq \varnothing$，$\pi[q] = 1 + \max\{k \in E_{q - 1}\}$。</p></li></ul><p align="right">$\blacksquare$ </p>              </div>            </details><hr><p>再来看看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcPi</span><span class="params">(<span class="keyword">char</span>* S)</span> </span>&#123;</span><br><span class="line">    pi[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, k = <span class="number">0</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; S[k + <span class="number">1</span>] != S[i])</span><br><span class="line">            k = pi[k];</span><br><span class="line">       <span class="keyword">if</span>(S[k + <span class="number">1</span>] == S[i])</span><br><span class="line">            ++k;</span><br><span class="line">       pi[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们将使用循环不变式来证明上述代码的正确性。</p><details ><summary> <p>证明</p> </summary>              <div class='content'>              <ul><li><p>初始化</p><p>在第 4 行的迭代开始前，有 $i = 1, k = \pi[i] = 0$，不变式成立。</p></li><li><p>保持</p><p>在每次迭代开始前，有 $k = \pi[i - 1]$：</p><ul><li>若是第一次迭代，此等式由第 4 行保证；</li><li>其余迭代均由第 9 行保证。</li></ul><p>接下来要证明每次迭代结束后均有 $k = \pi[i]$ 成立。</p><p>若 $k \neq \pi[i]$，则会在第 5-8 行将 $k$ 调整至 $\pi[i]$。</p><ul><li>第 5 行的 <code>while</code> 循环遍历每一个 $k \in \pi^{\star}[i - 1]$，直至找到一个 $k$，使得 $S[k + 1] = S[i]$。（引理 2）<ul><li>若找不到这样的值，则在第 7 行 $k = 0$。</li><li>若找到了这样的值，此时 $k$ 为满足条件的集合中的最大值，应将 $\pi[i] \gets k + 1$。（推论 1）</li></ul></li></ul><p>第 9 行的赋值语句使得 $k = \pi[i]$ 恒成立。</p></li><li><p>终止</p><p>当 $i = n + 1$ 时，迭代终止，此时我们求出了 $\pi[1..n]$。</p><p>至此，算法结束。</p></li></ul><p>因此，上述代码实现能正确地求出字符串 $S$ 的前缀函数数组。</p><p align="right">$\blacksquare$ </p>              </div>            </details><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>不难发现，第 7-9 行代码的时间复杂度均为 $O(n)$，唯一棘手的是第 6-7 行代码。</p><p>考虑 $k$ 的变化，$k$ 在第 7-8 行增加的次数不超过 $n$ 次，即 $k \le n$；</p><p>$k$ 在第 6 行的操作中，因为有 $\pi(S_i) &lt; i$ 的性质，导致每次迭代至少使 $k$ 减小 $1$，即最多迭代 $n$ 次。</p><p>综上所述，用上述方法求一个字符串的前缀函数数组的时间复杂度为 $O(n)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>易知用此种方法求前缀函数数组的空间复杂度为 $O(n)$。</p><h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><h4 id="正确性-1"><a href="#正确性-1" class="headerlink" title="正确性"></a>正确性</h4><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 前缀函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】EERTREE 学习笔记</title>
      <link href="/2020/06/22/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91EERTREE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/06/22/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91EERTREE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>EERTREE，又称回文树（Palindrome tree）、回文自动机（PAM），是一种能在 $O(\left|S\right|\log{\left|\Sigma\right|})$ 的时间与 $O(\left|S\right|)$ 的空间内处理与 <strong>回文串</strong> 有关问题的数据结构。</p><blockquote><p>EERTREE 是一个 <strong>回文串</strong>，也许这就是这个数据结构的名字的来历。</p></blockquote><p>回文树的高级应用慢慢写，持续更新。</p><p><a href="https://arxiv.org/pdf/1506.04862v2.pdf" target="_blank" rel="noopener">pdf 论文</a></p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>为了更方便地描述字符串相关内容，我们做出以下规定：</p><ol><li>$S, T$ 通常表示一个字符串，$c$ 通常表示一个字符，$\Sigma$ 表示字符集；</li><li>$\left|S\right|$ 表示字符串长度；</li><li>$\left|\Sigma\right|$ 表示字符集大小；</li><li>$S[l..r]$ 表示 $S[l], S[l + 1], \ldots, S[r - 1], S[r]$；</li><li>$\epsilon$ 表示空串；</li><li>$S \subset T$ 表示 $S$ 为 $T$ 的子串，即  $\exists i \in [1, \left|T\right| - \left|S\right|], \text{s.t. } \forall j \in [1, \left|S\right|], S[j] = T[i + j - 1]$；</li><li>$\overleftarrow{S}$ 表示 $S$ 的翻转，即 $\forall i \in [1, \left|S\right|], \overleftarrow{S[i]} = S[\left|S\right|- i + 1]$；</li><li>$S$ 为回文串当且仅当 $S = \overleftarrow{S}$，即 $\forall i \in [1, \left|S\right|], S[i] = S[\left|S\right| - i + 1]$；</li><li>若 $S$ 为回文串，则定义 $r(S)$ 为其最长回文半径，即 $r(S) = \max\{\left\lfloor\dfrac{\left|T\right| + 1}{2}\right\rfloor\}, T \subset S, T = \overleftarrow{T}$。</li></ol><p>特殊地，本文的字符串下标、回文树内节点编号 <strong>均从 $1$ 开始</strong>。</p><blockquote><p>一些例子：对于 $S = \mathtt{ABCBAD}$ 而言：</p><ol><li>$\left|S\right| = 6$；</li><li>$\left|\Sigma\right| = 4$；</li><li>$S[2..4] = \mathtt{BCBA}$；</li><li>$S[1..4] \subset S[1..5]$；</li><li>$\overleftarrow{S[3..5]} = \mathtt{DAB}$；</li><li>$S[1..5] = \mathtt{ABCBA} = \overleftarrow{S[1..5]}$ 为回文串。</li></ol></blockquote><h3 id="结构、操作与建立"><a href="#结构、操作与建立" class="headerlink" title="结构、操作与建立"></a>结构、操作与建立</h3><h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h4><p>我们考虑一个长度为 $n$ 的回文串 $S$，令 $P = { T : T = S[i..n - i + 1] \quad i \in [1, \left\lfloor\dfrac{n + 1}{2}\right\rfloor]}$，则 $\forall x \in P, x = \overleftarrow{x}$。</p><p>那么 $\forall x \in P$ 之间又有什么样的关系呢？</p><p>不难发现，一个回文串，是很多 <strong>子回文串层层嵌套</strong> 而成的。</p><p>也就是说，一个回文串，通过 <strong>在两端添加相同的字符</strong>，可以形成一个新的回文串。</p><p>至此，我们寻觅到了回文树上 <strong>边的意义</strong>。</p><p>在回文树中，$u$ 的父亲连向 $u$ 的边上存储着字符 $c$ 的意义是 $u$ 的父亲表示的回文串，在两端加上 $c$ 后，能形成 $u$。</p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><div class="note success">            <p>引理 1：向 $S$ 末尾添加一个字符 ，最多只会新生成一个回文子串。</p>          </div><details ><summary> <p>证明</p> </summary>              <div class='content'>              <p>这个子串是 $S$ 的 <strong>最长回文后缀</strong> 末端增加 $c$，且原来的前端恰好也是 $c$，所产生的。</p><p>也就是说，每次在 $S$ 的末尾添加一个字符，最多只会新建一个节点。</p><p align="right">$\blacksquare$ </p>              </div>            </details><p>回文树的内部结构，是一个包含着额外信息的有向图。</p><p>在后文中，我们可能会用回文子串来表示一个节点。</p><p>回文树支持两个操作：$\text{add}(c)$ 和 $\text{eertree}(S)$。</p><ul><li><p>$\text{add}(c)$ 表示在回文树内插入 $c$，返回此次操作新增的回文子串个数。</p><p>通过引理 1，我们可以知道 $\text{add}(c)$ 总是返回 $0$ 或 $1$。</p><p>不难发现，每次 $\text{add}$ 操作之后，我们都能在 $O(1)$ 的时间内得到已经处理了的字符串 $T$ 的最长回文后缀，即 $\text{maxSuf}(T)$。</p></li><li><p>$\text{eertree}(S)$ 表示将 $S$ 内的字符，从左至右逐个插入后形成的回文树。</p></li></ul><div class="note warning">            <p>小结 1：$S$ 中包含的本质不同的回文子串数量为 $\text{eertree}(S)$ 的节点中的最大编号。</p>          </div><p>一棵回文树上的每一个节点上要存储的信息有：</p><ol><li>这个点的序号 $u$；</li><li>表示的回文串的长度 $len_u$；</li><li>从这个点出发的一条标为 $c$ 的出边指向的节点的编号 $ch_{u, c}$；</li><li>回文链接 $fail_u$；</li></ol><p>为了以后的方便，我们需要在初始化的时候新建两个节点，长度和编号分别为 $-1$ 和 $0$。</p><p>$0$ 表示着空串，称之为「偶根」；而 $-1$ 表示着「虚串」，称之为「奇根」。</p><ul><li>偶根（即 $0$）连出的边（如果存在），指向 $cc$，表示在 $\epsilon$ 的两侧同时添加 $c$ 所形成的的字符串为 $cc$；</li><li>奇根（即 $-1$）连出的边（如果存在），指向 $c$，表示原来长度为 $-1$ 的串，在两侧同时添加 $c$ 形成了长度为 $1$ 的字符串 $c$。</li></ul><p>节点 $u$ 连至 $v$ 的回文链接 $fail_u$ 意味着 $v$ 表示的回文串 $S$ 是 $u$ 表示的回文串 $T$ 的次长回文后缀子串（因为最长的是自己本身）。</p><p>我们 <strong>定义</strong> $fail_c = 0, fail_0 = fail_{-1} = -1$。 </p><div class="note success">            <p>引理 2：任一满足 $len_u &gt; 0$ 的节点 $u$ 的入度为 $1$（注意，这里的「入度」不将「后缀链接」计算在内）。</p>          </div><details ><summary> <p>证明</p> </summary>              <div class='content'>              <ol><li><p>若 $len_u = 1$，则其唯一的入边必为 $-1 \to u$；</p></li><li><p>若 $len_u = 2$，则其唯一的入边必为 $0 \to u$；</p></li><li><p>若 $len_u \ge 3$，则其唯一的入边必为 $v \to u$，满足：$v$ 表示的回文子串 $T$ 的两端添加某个字符 $c$ 能使得 $u$ 表示的回文子串 $S$ 满足 $S = cTc$。</p></li></ol><p>综上所述，任一满足 $len_u &gt; 0$ 的节点 $u$ 的入度为 $1$。</p><p align="right">$\blacksquare$ </p>              </div>            </details><div class="note success">            <p>命题 1：建立一个长度为 $n$ 的字符串 $S$ 的回文树 $\text{eertree}(S)$ 的空间复杂度为 $O(n)$。</p>          </div><details ><summary> <p>证明</p> </summary>              <div class='content'>              <p>由引理 1 可知，在 $S$ 的逐步插入过程中，最多会新建 $n$ 个节点；而还有 $2$ 个初始化时新建的节点。</p><p>所以节点个数为最多为 $n + 2$ 个。</p><p>由引理 2 可知，边的个数最多为 $n$ 个；后缀链接最多有 $n$ 个。</p><p>综上所述，建立 $\text{eertree}(S)$ 的空间复杂度为 $O(n)$。</p><p align="right">$\blacksquare$ </p>              </div>            </details><h4 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h4><p>以 $S_0 = \mathtt{EERTREE}$ 为例，我们对它建立一棵回文树。</p><ol><li><p>首先，我们先新建两个点，钦定它们为「奇根 $1$」和「偶根 $0$」。</p><p>一棵空的回文树是这样的（红色边为 $fail$ 边，蓝色边为 $ch$ 边，后同）：</p><p><img src="/gallery/lectures/eertree/ex-null.png" alt="一棵空的 EERTREE"></p></li><li><p>然后我们插入 $\mathtt{E}$，现在 $S = \mathtt{E}$。</p><p><img src="/gallery/lectures/eertree/ex-e.png" alt="插入 &#39;E&#39; 后的 EERTREE"></p></li><li><p>接着我们插入 $\mathtt{E}$，现在 $S = \mathtt{EE}$。</p><p><img src="/gallery/lectures/eertree/ex-ee.png" alt="插入 &#39;EE&#39; 后的 EERTREE"></p></li><li><p>接着我们插入 $\mathtt{R}$，现在 $S = \mathtt{EER}$。</p><p><img src="/gallery/lectures/eertree/ex-eer.png" alt="插入 &#39;EER&#39; 后的 EERTREE"></p></li><li><p>接着我们插入 $\mathtt{T}$，现在 $S = \mathtt{EERT}$。</p><p><img src="/gallery/lectures/eertree/ex-eert.png" alt="插入 &#39;EERT&#39; 后的 EERTREE"></p></li><li><p>接着我们插入 $\mathtt{R}$，现在 $S = \mathtt{EERTR}$。</p><p><img src="/gallery/lectures/eertree/ex-eertr.png" alt="插入 &#39;EERTR&#39; 后的 EERTREE"></p></li><li><p>接着我们插入 $\mathtt{E}$，现在 $S = \mathtt{EERTRE}$。</p><p><img src="/gallery/lectures/eertree/ex-eertre.png" alt="插入 &#39;EERTRE&#39; 后的 EERTREE"></p></li><li><p>接着我们插入 $\mathtt{E}$，现在 $S = \mathtt{EERTREE}$。</p><p><img src="/gallery/lectures/eertree/ex-eertree.png" alt="插入 &#39;EERTREE&#39; 后的 EERTREE"></p></li></ol><p>我们应该如何实现这个过程呢？</p><div class="note success">            <p>命题 2：建立一个长度为 $n$ 的字符串 $S$ 的回文树 $\text{eertree}(S)$ 的时间复杂度可达到在线 $O(n\log\left|\Sigma\right|)$。</p>          </div><details ><summary> <p>证明</p> </summary>              <div class='content'>              <p>在初始化的时候，我们得到了 $\text{eertree}(\epsilon)$，即一个「奇根」和一个「偶根」加上它们的后缀链接。</p><p>对 $S$ 建造回文树的时候，我们会依次向回文树中插入 $S[1], S[2], \ldots, S[n]$。</p><p>我们要使得在每次 $\text{add}$ 操作之后，回文树中的所有节点之间的边以及回文链接都被正确维护。</p><p>考虑进行完了第 $i$ 次操作后的状态，也就是我们已经处理了 $T = S[1, i]$ 的回文树，现在要插入 $c = S[i + 1]$。</p><hr><p>我们现在的目标是寻找 $S[1..i + 1] = Tc$ 的最长回文后缀 $P$。</p><p>显然，要么 $P = c$，要么 $P = cQc$（显然 $Q$ 为 $S[1..i]$ 的某一回文后缀）。</p><p>也就是说，我们需要找到 $T$ 中，以 <strong>开头的前一位</strong> 为 $c$ 的最长回文后缀 $Q$。</p><p>我们从 $\text{maxSuf}(T)$ 开始，沿着回文链接遍历，设当前节点为 $v$，比较 $c$ 和 $T[i - len_v - 1]$。</p><p>怎么理解呢？$T[i - len_v..i - 1]$ 是某一回文串 $Q$，我们要找的，是满足 $Q$ 开头的前一位为 $c$ 的某一回文串。</p><p>也就是要保证 $c = T[i - len_v - 1]$。</p><p>不难发现，特殊地，当 $P = c$ 时，$Q$ 对应的节点为「奇根」。</p><hr><ol><li><p>若 $P = c$：</p><p>检查 $ch_{-1, c}$ 是否存在：</p><ol><li>若不存在，则新建一个节点 $v$，使 $ch_{-1, c} = v, len_v = 1, fail_v = 0$。</li><li>若存在，根据定义，$fail_v = 0$ 不需要更新。</li></ol></li><li><p>若 $P = cQc$：</p><p>设 $Q$ 对应的节点的序号为 $u$。</p><p>检查 $ch_{u, c}$ 是否存在：</p><ol><li><p>若不存在，则新建一个节点 $v$，使 $len_v = len_u + 2$，连接 $u \to v$，还要更新 $fail_v$。</p></li><li><p>若存在，我们只需要考虑更新 $fail_v$。</p></li></ol><p>考虑 $fail_v$ 到底会指向哪里？会指向 $S[1, i + 1] = Tc$ 的次长回文后缀。</p><p>即 $cQc$ 中 <strong>开头的前一位</strong> 为 $c$ 的次长回文后缀 $R$。</p><p>若我们从 $u$ 开始遍历后缀链接，那么找到的会是 $cQc$ 这个最长回文后缀；</p><p>因此我们应从 $fail_u$ 开始遍历，仍然是比较 $c$ 和 $T[i - len_v - 1]$。</p></li></ol><hr><p>接下来我们来分析 $\text{add}$ 操作的时间复杂度。</p><ol><li><p>我们每次检查 $ch_{u, c}$（或是检查 $ch_{-1, c}$）是否存在，需要 $O(\log\left|\Sigma\right|)$ 的时间复杂度（<code>std::map</code> 之类的数据结构实现）</p><p>实际情况下，我们使用子节点数组来实现，单次 $\text{add}$ 的时间复杂度是 $O(\left|\Sigma\right|)$ 的。</p><p>则一共 $n$ 次，共 $O(n \log\left|\Sigma\right|)$。</p></li><li><p>令已经处理了的字符串 $S[1..i] = T$，考虑 $\text{maxSuf}(T)$ 的末尾在 $S$ 中的下标 $j$ 的变化：</p><ul><li><p>一个 $fail$ 的转移会使 $j$ 向左至少移动 $1$ 格；</p></li><li><p>一个 $ch$ 转移会使 $j$ 向右至少移动一格。</p></li></ul><p>在处理整个 $S$ 的过程中，向左最多移动 $n$ 格，也就是最多 $n$ 次；向右最多移动 $n$ 格，也就是最多 $n$ 次。</p><p>因此转移部分的时间复杂度为总共 $O(n)$。</p></li></ol><p>总时间复杂度为 $O(n) + O(n\log\left|\Sigma\right|) = O(n\log\left|\Sigma\right|)$。</p><p>综上所述，建立一个长度为 $n$ 的字符串 $S$ 的回文树 $\text{eertree}(S)$ 的时间复杂度可达到在线 $O(n\log\left|\Sigma\right|)$。</p><p align="right">$\blacksquare$ </p>              </div>            </details><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>后文有吧。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>我们称一个节点 $u$ 是「奇」的，当且仅当 $len_u$ 为奇数；称一个节点 $v$ 是「偶」的，当且仅当 $len_v$ 为偶数。</p><div class="note success">            <p>引理 3：</p><ol><li>一棵回文树本质上是两个弱连通图：以「奇根」和「奇点」构成的一个弱连通子图和以「偶根」和「偶点」构成的一个弱连通子图，且均为树。</li><li>「奇点」和与其相连的边构成的树是 $S$ 右半部分长度为奇数的回文子串构成的 trie；「偶点」和与其相连的边构成的树是 $S$ 右半部分长度为偶数的回文子串构成的 trie。</li><li>一棵回文树中的所有节点与连接在每个节点上的回文链接的反向链接构成一棵有向基环树，其中环为 $-1$ 节点的自环。</li></ol>          </div><details ><summary> <p>证明</p> </summary>              <div class='content'>              <ol><li><p>如果边 $e = u \to v$ 存在，则 $len_v = len_u + 2$，显然 $u, v$ 奇偶性相同，则「奇点」与「偶点」之间互不相通。</p><p>结合引理 2，此性质得证。</p></li><li><p>这是回文树上边的定义和 trie 的定义。</p></li><li><p>注意到，除了 $fail_{-1}$，其他的回文链接均会使 $len$ 减小，且回文树中的每个点均有唯一的后缀链接。</p><p>则每个点都仅有唯一简单路径到达 $-1$，这显然是一棵（带有一个环）的树。</p></li></ol><p align="right">$\blacksquare$ </p>              </div>            </details><div class="note warning">            <p>小结 2：一些基本的字符串数据结构如回文 trie、后缀 trie 的空间复杂度都是 $O(n^2)$ 的；像后缀树和 Compressed trie 这样很复杂的数据结构空间复杂度是 $O(n)$ 的。但回文树这么简明易懂的数据结构的空间复杂度也是 $O(n)$ 的。<del>岂不妙哉？</del> 更重要的是，<strong>一个字符串中本质不同的回文串期望个数</strong> 是 $O(\sqrt{\left|S\right|\cdot\left|\Sigma\right|})$ 的。也就是说，回文树的期望空间复杂度更佳。</p>          </div><div class="note warning">            <p>小结 3：我们定义一个映射 $\theta :\Sigma \to \Sigma, \text{s.t. } \theta^2(S) = S$。我们称一个字符串 $S$ 是 $\theta$-回文的，当且仅当 $S = \theta(\overleftarrow{S})$。一个长度为 $n$ 的字符串 $S$ 的 $\theta$-回文树仍可以在 $O(\left|S\right|\log{\left|\Sigma\right|})$ 的时间与 $O(\left|S\right|)$ 的空间内建立起来。</p>          </div><h3 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h3><ol><li><p><a href="https://www.luogu.com.cn/problem/P3649" target="_blank" rel="noopener">「APIO2014」回文串</a></p><blockquote><p>题意：给定一个长度为 $n$ 的字符串 $S$，求 $\max\{\left|T\right|\cdot \text{occ}(S, T)\}, T \subset S \land T = \overleftarrow{T}$。</p><p>其中 $\text{occ}(S, T)$ 表示 $T$ 在 $S$ 中的出现次数，$1 \le \left|S\right| \le 3 \cdot 10^5$。</p></blockquote></li><li><p><a href="https://drive.google.com/file/d/0B_DHLY8icSyNUzRwdkNFa2EtMDQ" target="_blank" rel="noopener">「MIPT Fall Programming Training Camp2014」B. Pairs</a></p><blockquote><p>题意：给定一个长度为 $n$，字符集为 $\Sigma$ 的字符串 $S$，求满足 $1 \le i \le j &lt; k \le n \land (S[i..j] = \overleftarrow{S[i..j]}) \land (S[j + 1..k] = \overleftarrow{S[j + 1..k]})$ 的三元组 $(i, j, k)$ 的个数。</p><p>$1 \le n \le 3 \cdot 10^5$</p></blockquote></li></ol><blockquote><p>性质 3：<a href="https://www.luogu.com.cn/problem/P3649" target="_blank" rel="noopener">「APIO2014」回文串</a> 能用回文树在 <strong>额外 $O(n)$ 的时间和空间</strong> 内解决。</p></blockquote><details ><summary> <p>证明</p> </summary>              <div class='content'>              <p>令 $\text{occ}[u]$ 表示节点 $u$ 对应的字符串 $T$ 在 $S$ 中的出现次数。</p><p>令 $\text{occAsMax}[u]$ 表示满足 $\text{maxSuf}(S[1, i]) = T$ 的 $i$ 的个数，这个可以直接在每次 $\text{add}$ 之后实时维护。</p><p>不难发现，<br>$$<br>\text{occ}[u] = \text{occAsMax}[u] + \sum_{v:fail_v = u}\text{occ}[v]<br>$$<br>因为，$T$ 在 $S$ 中出现，要么是以 $T = \text{maxSuf}(S[1..i])$ 的形式出现，要么是以 $T = \text{maxSuf}(S[l..r]), S[l..r] = \overleftarrow{S[l..r]}$ 的形式出现。</p><p>考虑到前者即 $\text{occAsMax}[u]$，后者即满足 $fail_v = u$ 的 $\text{occ}[v]$，则上述式子成立。</p><p>由引理 3 可知，我们可以自底向上地维护 $\text{occ}[u]$。</p><p>（<code>maxNode</code> 是最大节点编号）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = maxNode; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    occ[i] = occAsMax[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = maxNode; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    occ[ fail[i] ] += occ[i];</span><br></pre></td></tr></table></figure><p>我们得到了 $\text{occ}$ 之后，答案即为 $\mathop{\operatorname{argmax}}\limits_{\text{occ}[u]}(\text{occ}[u]\cdot len_u)$。</p><hr><p>不难发现，这额外维护的一部分时间复杂度和空间复杂度均为 $O(n)$。</p><hr><p>在实现的过程中，因为 C++ 不支持访问负数数组下标，所以我们 <strong>整体把下标加一</strong>，即 $0$ 代表「奇根」，$1$ 代表「偶根」……以此类推。</p><p>此时 <code>maxNode</code> 即为 <code>cntNode - 1</code>，$1$ 号节点的编号实际上为 $2$（处理 $\text{occ}$ 的时候要注意）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> C = <span class="number">26</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EERTREE</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MS = N;</span><br><span class="line">    <span class="keyword">int</span> n, cntNode, last, s[MS], len[MS], ch[MS][C], fail[MS];</span><br><span class="line">    <span class="keyword">int</span> occAsMax[MS], occ[MS];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span> ll)</span> </span>&#123;</span><br><span class="line">        len[cntNode] = ll;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; ++i)</span><br><span class="line">            ch[cntNode][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> cntNode++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s[n] != s[n - len[x] - <span class="number">1</span>])</span><br><span class="line">            x = fail[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s[++n] = x;</span><br><span class="line">        <span class="keyword">int</span> u = getfail(last), flg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!u) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ch[u][x]) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = make(<span class="number">1</span>);</span><br><span class="line">                ch[u][x] = v;</span><br><span class="line">                fail[v] = <span class="number">1</span>;</span><br><span class="line">                flg = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ch[u][x]) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = make(len[u] + <span class="number">2</span>);</span><br><span class="line">                ch[u][x] = v;</span><br><span class="line">                flg = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fail[ ch[u][x] ] = ch[getfail(fail[u])][x];</span><br><span class="line">        &#125;</span><br><span class="line">        last = ch[u][x];</span><br><span class="line">        ++occAsMax[last];</span><br><span class="line">        <span class="keyword">return</span> flg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">getocc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 这里要注意迭代的范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cntNode - <span class="number">1</span>; i &gt;= <span class="number">2</span>; --i)</span><br><span class="line">            occ[i] = occAsMax[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cntNode - <span class="number">1</span>; i &gt;= <span class="number">2</span>; --i)</span><br><span class="line">            occ[ fail[i] ] += occ[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cntNode - <span class="number">1</span>; i &gt;= <span class="number">2</span>; --i)</span><br><span class="line">            ans = <span class="built_in">std</span>::max(ans, <span class="number">1L</span>L * occ[i] * len[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = cntNode = last = <span class="number">0</span>;</span><br><span class="line">        make(<span class="number">-1</span>), make(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">    m = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    t.init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        t.add(str[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, t.getocc());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align="right">$\blacksquare$ </p>              </div>            </details><blockquote><p>性质 4：<a href="https://drive.google.com/file/d/0B_DHLY8icSyNUzRwdkNFa2EtMDQ" target="_blank" rel="noopener">「MIPT Fall Programming Training Camp2014」B. Pairs</a> 能用回文树在 <strong>额外 $O(n\log\left|\Sigma\right|)$ 的时间和 $O(n)$ 的空间</strong> 内解决。</p></blockquote><details ><summary> <p>证明</p> </summary>              <div class='content'>              <p>首先，我们建立起 $\text{eertree}(S)$。</p><p>我们用 $\text{maxSuf}[i]$ 来表示  $\text{maxSuf}(S[1..i])$，这个显然能在 $O(n)$ 的空间内在每次 $\text{add}$ 操作之后维护。</p><p>我们令 $\text{sufCount}[u]$ 表示编号为 $u$ 的节点对应的字符串的回文后缀的个数。</p><p>同理我们还要求出 $\text{maxPre}$ 与 $\text{preCount}$。注意到它们分别对应的是 $\overleftarrow{S}$ 的 $\text{maxSuf}$ 和 $\text{sufCount}$（记为 $\text{maxSuf}’$ 和 $\text{sufCount}’$。。</p><p>于是，我们建立起 $\text{eertree}(\overleftarrow{S})$。</p><p>答案即为<br>$$<br>\sum_{i = 1}^{n - 1}\text{sufCount}[\text{maxSuf}[i]]\cdot\text{sufCount}’[\text{maxSuf}’[n - i]]<br>$$</p><hr><p>不难发现这部分的时间复杂度是 $O(n\log\left|\Sigma\right|)$ 的，空间复杂度是 $O(n)$ 的。</p><p><del>md 没得地方交这道题，代码仅供参考。</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> C = <span class="number">26</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line">LL ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EERTREE</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MS = N;</span><br><span class="line">    <span class="keyword">int</span> n, cntNode, s[MS], len[MS], ch[MS][C], fail[MS];</span><br><span class="line">    <span class="keyword">int</span> sufCount[MS], maxSuf[MS];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span> ll)</span> </span>&#123;</span><br><span class="line">        len[cntNode] = ll;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; ++i)</span><br><span class="line">            ch[cntNode][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> cntNode++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s[n] != s[n - len[x] - <span class="number">1</span>])</span><br><span class="line">            x = fail[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s[++n] = x;</span><br><span class="line">        <span class="keyword">int</span> u = getfail(maxSuf[n - <span class="number">1</span>]), flg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!u) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ch[u][x]) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = make(<span class="number">1</span>);</span><br><span class="line">                fail[v] = <span class="number">1</span>;</span><br><span class="line">                ch[u][x] = v;</span><br><span class="line">                flg = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ch[u][x]) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = make(len[u] + <span class="number">2</span>);</span><br><span class="line">                ch[u][x] = v;</span><br><span class="line">                flg = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fail[ ch[u][x] ] = ch[getfail(fail[u])][x];</span><br><span class="line">        &#125;</span><br><span class="line">        sufCount[ch[u][x]] = sufCount[ fail[ch[u][x]] ] + <span class="number">1</span>;</span><br><span class="line">        maxSuf[n] = ch[u][x];</span><br><span class="line">        <span class="keyword">return</span> flg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = cntNode;</span><br><span class="line">        <span class="built_in">memset</span>(maxSuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(maxSuf));</span><br><span class="line">        make(<span class="number">-1</span>), make(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t1, t2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">    m = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    t1.init(), t2.init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        t1.add(str[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        t2.add(str[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m - <span class="number">1</span>; ++i)</span><br><span class="line">        ans += t1.sufCount[ t1.maxSuf[i] ]</span><br><span class="line">                *</span><br><span class="line">               t2.sufCount[ t2.maxSuf[m - i] ];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align="right">$\blacksquare$ </p>              </div>            </details><h3 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h3><h4 id="并回文树"><a href="#并回文树" class="headerlink" title="并回文树"></a>并回文树</h4><p>与多个串的回文串相关的问题，我们可以用 <strong>并回文树</strong> 来解决。</p><p>我们用 $\text{eertree}(S_1, S_2, \ldots, S_n)$ 表示 $S_1, S_2, \ldots, S_n$ 的并回文树。</p><h4 id="支持删除的回文树"><a href="#支持删除的回文树" class="headerlink" title="支持删除的回文树"></a>支持删除的回文树</h4><h4 id="富字符串计数"><a href="#富字符串计数" class="headerlink" title="富字符串计数"></a>富字符串计数</h4><h4 id="可持久化回文树"><a href="#可持久化回文树" class="headerlink" title="可持久化回文树"></a>可持久化回文树</h4><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>回文树真的能很巧妙地解决与回文串有关的问题，</p><p>而且很多与回文串有关的问题的暴力的时间复杂度极劣无比，</p><p>这也能从侧面体现出回文树的巧妙。</p><blockquote><p>与字符串有关的数据结构都巧夺天工。</p></blockquote><p>用一首前人写的诗作结尾：</p><p>$$<br>\begin{aligned}<br> &amp; \textit{I think that I shall never see}<br> \\<br> &amp; \textit{A poem lovely as a tree.}<br> \\<br> &amp; \textit{Poems are made by fools like me,}<br> \\<br> &amp; \textit{But only God can make a tree.}<br>\end{aligned}<br>$$</p><p>接下来就开始努力钻研后缀树吧。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 回文树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
