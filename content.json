{"meta":{"title":"Clever_Jimmy's blog","subtitle":"","description":"","author":"Clever_Jimmy","url":"https://leverimmy.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-07-02T08:23:19.149Z","updated":"2020-07-02T08:23:19.149Z","comments":true,"path":"404.html","permalink":"https://leverimmy.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-07-02T08:23:41.008Z","updated":"2020-07-02T08:23:41.008Z","comments":true,"path":"about/index.html","permalink":"https://leverimmy.top/about/index.html","excerpt":"","text":"窝是 $\\text{Clever_Jimmy}$，一名来自 HB 的 OIer。 OI 水平比较菜，喜欢打皇室战争、荒野乱斗。 希望有大佬跟窝互换友链呀(=￣ω￣=) 窝的 cf 账号们： 备忘小提示 多写注释； LaTeX 指南 「也许，同学间最好的结局就是朋友吧。」 后缀树建造过程 「你自己才是自己的原动力。你把原动力都掐熄火了，还能干嘛呢？」 头像网址 LaTeX 索引（支持查找关键字） 算法及数据结构可视化 Visualization 各大 OJ 通过数统计 statistics QQ 表情 图床地址 SVG 图像 绘制 int mul(int ta, int tb, int mod) { int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(ta), \"b\"(tb), \"c\"(mod)); return ret; } 大事祭 日期 事情 2018.07.01 成功 祭 2018.11.11 完成第一次 NOIP 祭 2019.11.17 完成第一次 CSP 祭 2020.01.01 失败 祭 2020.01.23 武汉封城祭 2020.03.10 CF 上 1800 祭 2020.03.22 第一次 AK ABC 祭 2020.03.30 第一次上 洛谷日报 祭 2020.06.08 CF Candidate Master 祭 2020.06.12 第一次 CF Successful Hack 祭（hack 的还是自己） 2020.06.12 CF 上 2000 祭 2020.06.14 第一次 举办洛谷公开赛 EasY Round祭"},{"title":"所有分类","date":"2020-07-02T07:55:54.061Z","updated":"2020-07-02T07:55:54.061Z","comments":true,"path":"categories/index.html","permalink":"https://leverimmy.top/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-07-02T07:55:35.544Z","updated":"2020-07-02T07:55:35.544Z","comments":true,"path":"tags/index.html","permalink":"https://leverimmy.top/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-07-02T08:21:38.106Z","updated":"2020-07-02T08:21:38.106Z","comments":true,"path":"friends/index.html","permalink":"https://leverimmy.top/friends/index.html","excerpt":"这些都是我的好朋友。","text":"这些都是我的好朋友。 如果希望互挂友链的，请联系我：506503360@qq.com。 欢迎哦~"}],"posts":[{"title":"【学习笔记】KMP 算法学习笔记","slug":"【学习笔记】KMP-算法学习笔记","date":"2020-06-29T03:41:18.000Z","updated":"2020-07-02T10:47:54.347Z","comments":true,"path":"2020/06/29/【学习笔记】KMP-算法学习笔记/","link":"","permalink":"https://leverimmy.top/2020/06/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91KMP-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"发现自己不会 KMP 的模板了，借此机会复习一下 KMP，顺便更深入地研究前缀函数 $\\pi$ 的应用。","text":"发现自己不会 KMP 的模板了，借此机会复习一下 KMP，顺便更深入地研究前缀函数 $\\pi$ 的应用。 写在前面为了更方便地描述字符串相关内容，我们做出以下规定： $S, T$ 通常表示一个字符串，$c$ 通常表示一个字符，$\\Sigma$ 表示字符集； $\\left|S\\right|$ 表示字符串长度； $\\left|\\Sigma\\right|$ 表示字符集大小； $S[l..r]$ 表示 $S[l], S[l + 1], \\ldots, S[r - 1], S[r]$； $\\epsilon$ 表示空串； $S$ 是 $T$ 的前缀，用 $S \\sqsubset T$ 表示；$S$ 是 $T$ 的后缀，用 $S \\sqsupset T$ 表示； $S_i$ 表示 $S[1..i]$，即 $S$ 的第 $i$ 个前缀。 特殊地，本文的字符串下标、$\\pi$ 数组下标 均从 $1$ 开始。 一些例子：对于 $S = \\mathtt{ABCBAD}$ 而言：$\\left|S\\right| = 6$；$\\left|\\Sigma\\right| = 4$；$S[2..4] = \\mathtt{BCBA}$；$S_4 = \\mathtt{ABCB}$。 前缀函数数组定义对于一个字符串 $S$，我们定义其前缀函数 $\\pi(S)$ 的值为 $S$ 的最长相等的真前缀和真后缀的长度，即：$$\\begin{aligned}\\pi(S) &amp; = \\mathop{\\operatorname{argmax}}\\limits_{k &lt; \\left|S\\right|}\\{S[1..k] = S[\\left|S\\right| - k + 1..\\left|S\\right|]\\}\\\\&amp; = \\mathop{\\operatorname{argmax}}\\limits_{k &lt; \\left|S\\right|}\\{S_k \\sqsupset S\\}\\end{aligned}$$对于一个字符串 $S$，我们定义其前缀函数数组 $\\pi$ 为 $\\pi[i] = \\pi(S_i)$。 特殊地，当 $\\left|S\\right| = 1$ 时 $\\pi(S) = \\mathop{\\operatorname{argmax}}\\limits_{k &lt; 1}\\{S[1..k] = S[2 - k..1]\\}$当 $k = 0$ 时 $S[1..0] = S[2..1] = \\epsilon$，故 $\\pi(S) = 0$。 性质 1：$\\pi(S_i) = \\pi[i] &lt; i$。 证明 由定义知 $\\pi[i] &lt; i$，即得证。$\\blacksquare$ 算法流程 根据定义，$\\pi[1] = 0$； 假设我们循环到了要求 $\\pi[i]\\quad(i \\ge 2)$，令 $k \\gets \\pi[i - 1]$。 由 $\\pi$ 数组的定义得，此时 $S[1..k] = S[i - k, i - 1]$。 我们现在要做的，就是从 $\\pi[1..i - 1]$ 递推到 $\\pi[i]$： 考虑到 $\\pi$ 数组的定义，我们不断地枚举共同的前后缀（即使用 $k = \\pi[k]$ 来迭代）。 结束这个迭代，有且仅有两种情况：$k = 0$ 或 $S[k + 1] = S[i]$。 对于前者，说明对于字符串 $S[1..i]$，不存在任何两个真前缀与真后缀相同，$\\pi[i] = 0$。 对于后者，说明我们找到了一个 $k$，使得 $S[1..k + 1] = S[i - k..i]$，根据定义，有 $\\pi[i] = k + 1$。 至此，我们求出了字符串 $S$ 的前缀函数数组 $\\pi$。 代码实现1234567891011void calcPi(char* S) &#123; pi[1] = 0; int len = strlen(S + 1); for(int i = 2, k = 0; i &lt;= len; ++i) &#123; while(k &gt; 0 &amp;&amp; S[k + 1] != T[i]) k = pi[k]; if(S[k + 1] == S[i]) ++k; pi[i] = k; &#125;&#125; 正确性 引理 1（后缀重叠引理）：对于 $x, y$ 满足 $x \\sqsupset z, y \\sqsupset z$ 而言，有若 $\\left|x\\right| \\le \\left|y\\right|$，则 $x \\sqsupset y$；若 $\\left|x\\right| \\ge \\left|y\\right|$，则 $y \\sqsupset x$；若 $\\left|x\\right| = \\left|y\\right|$，则 $x = y$。 证明 过于显然，证明略。$\\blacksquare$ 设$$\\pi^{\\star}[q] = \\{\\pi[q], \\pi^{(2)}[q], \\cdots, \\pi^{(t)}[q]\\}$$其中$$\\pi^{(i)}[q] = \\begin{cases}q &amp; i = 0 \\\\ \\pi[\\pi^{(i - 1)}[q]] &amp; i \\ge 1\\end{cases}$$ 当 $\\pi^{(t)}[q] = 0$ 时 $\\pi^{\\star}[q]$ 中的序列终止。 引理 2（前缀函数迭代引理）：对任意长度为 $n$ 的字符串 $S$，有$$\\forall q \\in [1, n], \\pi^{\\star}[q] = \\{k: k &lt; q \\land S_k \\sqsupset S_q\\}$$ 证明 先证明 $\\pi^{\\star}[q] \\subseteq \\{k:k &lt; q \\land S_k \\sqsupset S_q\\}$，即证明 $\\forall x \\in \\pi^{\\star}[q], x &lt; q \\land S_x \\sqsupset S_q$。任取 $x \\in \\pi^{\\star}[q]$，不妨设 $x = \\pi^{u}[q] \\quad (u &gt; 0)$，下面通过对 $u$ 的数学归纳法证明命题成立。（基础）当 $u = 1$ 时，$x = \\pi[q]$，由 $\\pi$ 数组的定义可知 $\\pi[q] &lt; q \\land S_{\\pi[q]} \\sqsupset S_q$。（假设）假设当 $u = v$ 时 $\\pi^{v}[q] &lt; q \\land S_{\\pi^{v}[q]} \\sqsupset S_q$。（推导）则当 $u = v + 1$ 时，$\\pi^{v + 1}[q] = \\pi[\\pi^{v}[q]] &lt; \\pi^{v}[q] &lt; q$（性质 1）；$S_{\\pi^{v + 1}[q]} \\sqsupset S_{\\pi^{v}[q]} \\sqsupset S_q$（由性质 1 得到下标的大小关系，由引理 1 得到前缀之间的关系）因此 $\\forall x \\in \\pi^{\\star}[q], x &lt; q \\land S_x \\sqsupset S_q$。再证明 $\\{k:k &lt; q \\land S_k \\sqsupset S_q\\} \\subseteq \\pi^{\\star}[q]$，即证明 $\\forall x \\in \\{k:k &lt; q \\land S_x \\sqsupset S_q\\}, x \\in\\pi^{\\star}[q]$考虑使用反证法来证明命题成立。假设集合 $M = \\{k:k &lt; q \\land S_k \\sqsupset S_q\\} - \\pi^{\\star}[q]$ 非空，$j$ 是 $M$ 中的最大值。$\\because$ $\\pi[q]$ 是 $\\{k:k &lt; q \\land S_x \\sqsupset S_q\\}$ 中的最大值，且 $j \\in \\{k:k &lt; q \\land S_x \\sqsupset S_q\\}$$\\therefore j &lt; \\pi[q], S_j \\sqsupset S_q$又 $\\because \\pi[q] \\in \\pi^{\\star}[q]$$\\therefore \\exists j’ \\in \\pi^{\\star}[q], \\text{s.t. }j’ &gt; j$设 $j’$ 表示 $\\pi^{\\star}[q]$ 中比 $j$ 大的最小整数。$\\because \\{k:k &lt; q \\land S_k \\sqsupset S_q\\} \\subseteq \\pi^{\\star}[q]$ 且 $j’ \\in \\pi^{\\star}[q]$$\\therefore S_{j’} \\sqsupset S_q$$\\because j’ &gt; j$ 且 $j$ 是小于 $j’$ 的最大值$\\therefore S_j \\sqsupset S_{j’}$（引理 1）由 $\\pi$ 数组的定义知 $\\pi[j’] = j$$\\because j’ \\in \\pi^{\\star}[q]$$\\therefore j = \\pi[j’] \\in \\pi^{\\star}[q]$，与假设矛盾因此 $\\{k:k &lt; q \\land S_k \\sqsupset S_q\\} \\subseteq \\pi^{\\star}[q]$。综上所述，对任意长度为 $n$ 的字符串 $S$，有 $\\forall q \\in [1, n], \\pi^{\\star}[q] = \\{k: k &lt; q \\land S_k \\sqsupset S_q\\}$。$\\blacksquare$ 引理 3：对任意长度为 $n$ 的字符串 $S$，有 $\\forall q \\in [1, n]$，若 $\\pi[q] &gt; 0$，则 $\\pi[q] - 1 \\in \\pi^{\\star}[q - 1]$。 证明 令 $x = \\pi[q] &gt; 0$，则 $x &lt; q, S_x \\sqsupset S_q$$\\because x &gt; 0$，则 $x - 1$ 有意义$\\therefore x - 1 &lt; q - 1, S_{x - 1} \\sqsupset S_{q - 1}$（把 $S_x$ 和 $S_q$ 的最后一个字符去掉） 由引理 2 知 $x - 1 \\in \\pi^{\\star}[q - 1]$$\\therefore \\forall q \\in [1, n] \\land \\pi[q] &gt; 0,\\pi[q] - 1 \\in \\pi^{\\star}[q - 1]$$\\blacksquare$ 对 $q \\in [2, n]$ 定义子集 $E_{q - i} \\subseteq \\pi^{\\star}[q - 1]$ 为： $$E_{q - 1} = \\{k\\in\\pi^{\\star}[q - 1]:S_{k + 1} = S_k\\}$$ 则有： $$\\begin{aligned} E_{q - 1} &amp; = \\{k\\in\\pi^{\\star}[q - 1]:S_{k + 1} = S_k\\} \\\\ &amp; = \\{k: k &lt; q - 1, S_k \\sqsupset S_{q - 1}, S[k + 1] = S[q]\\} \\\\ &amp; = \\{k: k &lt; q - 1, S_{k + 1} \\sqsupset S_q\\}\\end{aligned}$$ 因此，$E_{q - 1}$ 是由 $\\pi^{\\star}[q - 1]$ 中的值组成的、能满足 $S_{k + 1}$ 与 $S_q$ 的某个后缀相等的 $k$ 组成的集合。 推论 1：对任意长度为 $n$ 的字符串 $S$，有$$\\forall q \\in [2, n],\\pi[q] = \\begin{cases}0 &amp; E_{q - 1} = \\varnothing \\\\ 1 + \\max\\{k \\in E_{q - 1}\\} &amp; E_{q - 1} \\neq \\varnothing\\end{cases}$$ 证明 当 $E_{q - 1} = \\varnothing$ 时，不存在任何一个 $k \\in \\pi^{\\star}[q - 1]$，使得 $S_{k + 1} \\sqsupset S_q$。显然此时 $\\pi[q]$ 只能为 $0$。当 $E_{q - 1} \\neq \\varnothing$ 时，$\\forall k \\in E_{q - 1}, k &lt; q - 1 \\land S_{k + 1} \\sqsupset S_q \\Longrightarrow k + 1 &lt; q$则由 $\\pi[q]$ 的定义，$k$ 是拓展到 $S_q$ 的某一后缀的备选项，$\\pi[q] \\ge 1 + \\max\\{k \\in E_{q - 1}\\}$。注意到此时 $\\pi[q] &gt; 0$，设 $r = \\pi[q] - 1$。则 $r + 1 = \\pi[q] &lt; q, S_{r + 1} = S_{\\pi[q]} \\sqsupset S_q$。$\\because r + 1 &gt; 0$$\\therefore S_{r + 1} = S_q$由引理 3 可得 $r = \\pi[q] - 1 \\in \\pi^{\\star}[q - 1]$$\\therefore r \\in E_{q - 1}$$\\therefore \\pi[q] - 1 = r \\le \\max\\{k \\in E_{q - 1}\\}$即 $\\pi[q] \\le 1 + \\max\\{k \\in E_{q - 1}\\}$综上所述，当 $E_{q - 1} \\neq \\varnothing$，$\\pi[q] = 1 + \\max\\{k \\in E_{q - 1}\\}$。$\\blacksquare$ 再来看看代码： 1234567891011void calcPi(char* S) &#123; pi[1] = 0; int len = strlen(S + 1); for(int i = 2, k = 0; i &lt;= len; ++i) &#123; while(k &gt; 0 &amp;&amp; S[k + 1] != S[i]) k = pi[k]; if(S[k + 1] == S[i]) ++k; pi[i] = k; &#125;&#125; 接下来我们将使用循环不变式来证明上述代码的正确性。 证明 初始化在第 4 行的迭代开始前，有 $i = 1, k = \\pi[i] = 0$，不变式成立。保持在每次迭代开始前，有 $k = \\pi[i - 1]$：若是第一次迭代，此等式由第 4 行保证；其余迭代均由第 9 行保证。接下来要证明每次迭代结束后均有 $k = \\pi[i]$ 成立。若 $k \\neq \\pi[i]$，则会在第 5-8 行将 $k$ 调整至 $\\pi[i]$。第 5 行的 while 循环遍历每一个 $k \\in \\pi^{\\star}[i - 1]$，直至找到一个 $k$，使得 $S[k + 1] = S[i]$。（引理 2）若找不到这样的值，则在第 7 行 $k = 0$。若找到了这样的值，此时 $k$ 为满足条件的集合中的最大值，应将 $\\pi[i] \\gets k + 1$。（推论 1）第 9 行的赋值语句使得 $k = \\pi[i]$ 恒成立。终止当 $i = n + 1$ 时，迭代终止，此时我们求出了 $\\pi[1..n]$。至此，算法结束。因此，上述代码实现能正确地求出字符串 $S$ 的前缀函数数组。$\\blacksquare$ 时间复杂度不难发现，第 7-9 行代码的时间复杂度均为 $O(n)$，唯一棘手的是第 6-7 行代码。 考虑 $k$ 的变化，$k$ 在第 7-8 行增加的次数不超过 $n$ 次，即 $k \\le n$； $k$ 在第 6 行的操作中，因为有 $\\pi(S_i) &lt; i$ 的性质，导致每次迭代至少使 $k$ 减小 $1$，即最多迭代 $n$ 次。 综上所述，用上述方法求一个字符串的前缀函数数组的时间复杂度为 $O(n)$。 空间复杂度易知用此种方法求前缀函数数组的空间复杂度为 $O(n)$。 KMP 算法算法流程代码实现正确性时间复杂度空间复杂度应用写在最后","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://leverimmy.top/tags/KMP/"},{"name":"字符串","slug":"字符串","permalink":"https://leverimmy.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"前缀函数","slug":"前缀函数","permalink":"https://leverimmy.top/tags/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0/"}]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://leverimmy.top/tags/KMP/"},{"name":"字符串","slug":"字符串","permalink":"https://leverimmy.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"前缀函数","slug":"前缀函数","permalink":"https://leverimmy.top/tags/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0/"}]}