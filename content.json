{"meta":{"title":"Clever_Jimmy's Blog","subtitle":"","description":"","author":"Clever_Jimmy","url":"https://leverimmy.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-07-02T08:23:19.149Z","updated":"2020-07-02T08:23:19.149Z","comments":true,"path":"404.html","permalink":"https://leverimmy.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-07-02T11:36:45.501Z","updated":"2020-07-02T11:36:45.501Z","comments":true,"path":"about/index.html","permalink":"https://leverimmy.top/about/index.html","excerpt":"","text":"窝是 Clever_Jimmy，一名来自 HB 的 OIer。 OI 水平比较菜，喜欢打皇室战争、荒野乱斗。 希望有大佬跟窝互换友链呀(=￣ω￣=) 窝的 cf 账号们： 备忘小提示 多写注释； LaTeX 指南 「也许，同学间最好的结局就是朋友吧。」 后缀树建造过程 「你自己才是自己的原动力。你把原动力都掐熄火了，还能干嘛呢？」 头像网址 LaTeX 索引（支持查找关键字） 算法及数据结构可视化 Visualization 各大 OJ 通过数统计 statistics QQ 表情 图床地址 SVG 图像 绘制 int mul(int ta, int tb, int mod) { int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(ta), \"b\"(tb), \"c\"(mod)); return ret; } 大事祭 日期 事情 2018.07.01 成功 祭 2018.11.11 完成第一次 NOIP 祭 2019.11.17 完成第一次 CSP 祭 2020.01.01 失败 祭 2020.01.23 武汉封城祭 2020.03.10 CF 上 1800 祭 2020.03.22 第一次 AK ABC 祭 2020.03.30 第一次上 洛谷日报 祭 2020.06.08 CF Candidate Master 祭 2020.06.12 第一次 CF Successful Hack 祭（hack 的还是自己） 2020.06.12 CF 上 2000 祭 2020.06.14 第一次 举办洛谷公开赛 EasY Round祭"},{"title":"所有分类","date":"2020-07-02T07:55:54.061Z","updated":"2020-07-02T07:55:54.061Z","comments":true,"path":"categories/index.html","permalink":"https://leverimmy.top/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-07-02T07:55:35.544Z","updated":"2020-07-02T07:55:35.544Z","comments":true,"path":"tags/index.html","permalink":"https://leverimmy.top/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-07-02T08:21:38.106Z","updated":"2020-07-02T08:21:38.106Z","comments":true,"path":"friends/index.html","permalink":"https://leverimmy.top/friends/index.html","excerpt":"这些都是我的好朋友。","text":"这些都是我的好朋友。 如果希望互挂友链的，请联系我：506503360@qq.com。 欢迎哦~"}],"posts":[{"title":"【学习笔记】KMP 算法学习笔记","slug":"【学习笔记】KMP-算法学习笔记","date":"2020-06-29T03:41:18.000Z","updated":"2020-07-03T05:43:10.418Z","comments":true,"path":"2020/06/29/【学习笔记】KMP-算法学习笔记/","link":"","permalink":"https://leverimmy.top/2020/06/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91KMP-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"发现自己不会 KMP 的模板了，借此机会复习一下 KMP，顺便更深入地研究前缀函数 $\\pi$ 的应用。","text":"发现自己不会 KMP 的模板了，借此机会复习一下 KMP，顺便更深入地研究前缀函数 $\\pi$ 的应用。 写在前面为了更方便地描述字符串相关内容，我们做出以下规定： 字符串通常用 $S, T$ 等表示，$c$ 通常表示一个字符，$\\Sigma$ 表示字符集； 字符串长度用 $\\left|S\\right|$ 表示； 字符集大小用 $\\left|\\Sigma\\right|$ 表示； $S[l..r]$ 表示 $S[l], S[l + 1], \\ldots, S[r - 1], S[r]$； 空串用 $\\epsilon$ 表示； $S$ 是 $T$ 的前缀，用 $S \\sqsubset T$ 表示；$S$ 是 $T$ 的后缀，用 $S \\sqsupset T$ 表示； $S$ 的第 $i$ 个前缀，即 $S[1..i]$，用 $S_i$ 表示。 特殊地，本文的字符串下标、$\\pi$ 数组下标 均从 $1$ 开始。 一些例子：对于 $S = \\mathtt{ABCBAD}$ 而言： $\\left|S\\right| = 6$； $\\left|\\Sigma\\right| = 4$； $S[2..4] = \\mathtt{BCBA}$； $S_4 = \\mathtt{ABCB}$。 前缀函数数组定义对于一个字符串 $S$，我们定义其前缀函数 $\\pi(S)$ 的值为 $S$ 的最长相等的真前缀和真后缀的长度，即：$$\\begin{aligned}\\pi(S) &amp; = \\mathop{\\operatorname{argmax}}\\limits_{k &lt; \\left|S\\right|}\\{S[1..k] = S[\\left|S\\right| - k + 1..\\left|S\\right|]\\}\\\\&amp; = \\mathop{\\operatorname{argmax}}\\limits_{k &lt; \\left|S\\right|}\\{S_k \\sqsupset S\\}\\end{aligned}$$对于一个字符串 $S$，我们定义其前缀函数数组 $\\pi$ 为 $\\pi[i] = \\pi(S_i)$。 特殊地，当 $\\left|S\\right| = 1$ 时 $\\pi(S) = \\mathop{\\operatorname{argmax}}\\limits_{k &lt; 1}\\{S[1..k] = S[2 - k..1]\\}$当 $k = 0$ 时 $S[1..0] = S[2..1] = \\epsilon$，故 $\\pi(S) = 0$。 性质 1：$\\pi(S_i) = \\pi[i] &lt; i$。 证明 由定义知 $\\pi[i] &lt; i$，即得证。$\\blacksquare$ 算法流程 根据定义，$\\pi[1] = 0$； 假设我们循环到了要求 $\\pi[i]\\quad(i \\ge 2)$，令 $k \\gets \\pi[i - 1]$。 由 $\\pi$ 数组的定义得，此时 $S[1..k] = S[i - k, i - 1]$。 我们现在要做的，就是从 $\\pi[1..i - 1]$ 递推到 $\\pi[i]$： 考虑到 $\\pi$ 数组的定义，我们不断地枚举共同的前后缀（即使用 $k = \\pi[k]$ 来迭代）。 结束这个迭代，有且仅有两种情况：$k = 0$ 或 $S[k + 1] = S[i]$。 对于前者，说明对于字符串 $S[1..i]$，不存在任何两个真前缀与真后缀相同，$\\pi[i] = 0$。 对于后者，说明我们找到了一个 $k$，使得 $S[1..k + 1] = S[i - k..i]$，根据定义，有 $\\pi[i] = k + 1$。 至此，我们求出了字符串 $S$ 的前缀函数数组 $\\pi$。 代码实现1234567891011void calcPi(char* S) &#123; pi[1] = 0; int len = strlen(S + 1); for(int i = 2, k = 0; i &lt;= len; ++i) &#123; while(k &gt; 0 &amp;&amp; S[k + 1] != T[i]) k = pi[k]; if(S[k + 1] == S[i]) ++k; pi[i] = k; &#125;&#125; 正确性 引理 1（后缀重叠引理）：对于 $x, y$ 满足 $x \\sqsupset z, y \\sqsupset z$ 而言，有若 $\\left|x\\right| \\le \\left|y\\right|$，则 $x \\sqsupset y$；若 $\\left|x\\right| \\ge \\left|y\\right|$，则 $y \\sqsupset x$；若 $\\left|x\\right| = \\left|y\\right|$，则 $x = y$。 证明 过于显然，证明略。$\\blacksquare$ 设$$\\pi^{\\star}[q] = \\{\\pi[q], \\pi^{(2)}[q], \\cdots, \\pi^{(t)}[q]\\}$$其中$$\\pi^{(i)}[q] = \\begin{cases}q &amp; i = 0 \\\\ \\pi[\\pi^{(i - 1)}[q]] &amp; i \\ge 1\\end{cases}$$ 当 $\\pi^{(t)}[q] = 0$ 时 $\\pi^{\\star}[q]$ 中的序列终止。 引理 2（前缀函数迭代引理）：对任意长度为 $n$ 的字符串 $S$，有$$\\forall q \\in [1, n], \\pi^{\\star}[q] = \\{k: k &lt; q \\land S_k \\sqsupset S_q\\}$$ 证明 先证明 $\\pi^{\\star}[q] \\subseteq \\{k:k &lt; q \\land S_k \\sqsupset S_q\\}$，即证明 $\\forall x \\in \\pi^{\\star}[q], x &lt; q \\land S_x \\sqsupset S_q$。任取 $x \\in \\pi^{\\star}[q]$，不妨设 $x = \\pi^{u}[q] \\quad (u &gt; 0)$，下面通过对 $u$ 的数学归纳法证明命题成立。（基础）当 $u = 1$ 时，$x = \\pi[q]$，由 $\\pi$ 数组的定义可知 $\\pi[q] &lt; q \\land S_{\\pi[q]} \\sqsupset S_q$。（假设）假设当 $u = v$ 时 $\\pi^{v}[q] &lt; q \\land S_{\\pi^{v}[q]} \\sqsupset S_q$。（推导）则当 $u = v + 1$ 时，$\\pi^{v + 1}[q] = \\pi[\\pi^{v}[q]] &lt; \\pi^{v}[q] &lt; q$（性质 1）；$S_{\\pi^{v + 1}[q]} \\sqsupset S_{\\pi^{v}[q]} \\sqsupset S_q$（由性质 1 得到下标的大小关系，由引理 1 得到前缀之间的关系）因此 $\\forall x \\in \\pi^{\\star}[q], x &lt; q \\land S_x \\sqsupset S_q$。再证明 $\\{k:k &lt; q \\land S_k \\sqsupset S_q\\} \\subseteq \\pi^{\\star}[q]$，即证明 $\\forall x \\in \\{k:k &lt; q \\land S_x \\sqsupset S_q\\}, x \\in\\pi^{\\star}[q]$考虑使用反证法来证明命题成立。假设集合 $M = \\{k:k &lt; q \\land S_k \\sqsupset S_q\\} - \\pi^{\\star}[q]$ 非空，$j$ 是 $M$ 中的最大值。$\\because$ $\\pi[q]$ 是 $\\{k:k &lt; q \\land S_x \\sqsupset S_q\\}$ 中的最大值，且 $j \\in \\{k:k &lt; q \\land S_x \\sqsupset S_q\\}$$\\therefore j &lt; \\pi[q], S_j \\sqsupset S_q$又 $\\because \\pi[q] \\in \\pi^{\\star}[q]$$\\therefore \\exists j’ \\in \\pi^{\\star}[q], \\text{s.t. }j’ &gt; j$设 $j’$ 表示 $\\pi^{\\star}[q]$ 中比 $j$ 大的最小整数。$\\because \\{k:k &lt; q \\land S_k \\sqsupset S_q\\} \\subseteq \\pi^{\\star}[q]$ 且 $j’ \\in \\pi^{\\star}[q]$$\\therefore S_{j’} \\sqsupset S_q$$\\because j’ &gt; j$ 且 $j$ 是小于 $j’$ 的最大值$\\therefore S_j \\sqsupset S_{j’}$（引理 1）由 $\\pi$ 数组的定义知 $\\pi[j’] = j$$\\because j’ \\in \\pi^{\\star}[q]$$\\therefore j = \\pi[j’] \\in \\pi^{\\star}[q]$，与假设矛盾因此 $\\{k:k &lt; q \\land S_k \\sqsupset S_q\\} \\subseteq \\pi^{\\star}[q]$。综上所述，对任意长度为 $n$ 的字符串 $S$，有 $\\forall q \\in [1, n], \\pi^{\\star}[q] = \\{k: k &lt; q \\land S_k \\sqsupset S_q\\}$。$\\blacksquare$ 引理 3：对任意长度为 $n$ 的字符串 $S$，有 $\\forall q \\in [1, n]$，若 $\\pi[q] &gt; 0$，则 $\\pi[q] - 1 \\in \\pi^{\\star}[q - 1]$。 证明 令 $x = \\pi[q] &gt; 0$，则 $x &lt; q, S_x \\sqsupset S_q$$\\because x &gt; 0$，则 $x - 1$ 有意义$\\therefore x - 1 &lt; q - 1, S_{x - 1} \\sqsupset S_{q - 1}$（把 $S_x$ 和 $S_q$ 的最后一个字符去掉） 由引理 2 知 $x - 1 \\in \\pi^{\\star}[q - 1]$$\\therefore \\forall q \\in [1, n] \\land \\pi[q] &gt; 0,\\pi[q] - 1 \\in \\pi^{\\star}[q - 1]$$\\blacksquare$ 对 $q \\in [2, n]$ 定义子集 $E_{q - i} \\subseteq \\pi^{\\star}[q - 1]$ 为： $$E_{q - 1} = \\{k\\in\\pi^{\\star}[q - 1]:S_{k + 1} = S_k\\}$$ 则有： $$\\begin{aligned} E_{q - 1} &amp; = \\{k\\in\\pi^{\\star}[q - 1]:S_{k + 1} = S_k\\} \\\\ &amp; = \\{k: k &lt; q - 1, S_k \\sqsupset S_{q - 1}, S[k + 1] = S[q]\\} \\\\ &amp; = \\{k: k &lt; q - 1, S_{k + 1} \\sqsupset S_q\\}\\end{aligned}$$ 因此，$E_{q - 1}$ 是由 $\\pi^{\\star}[q - 1]$ 中的值组成的、能满足 $S_{k + 1}$ 与 $S_q$ 的某个后缀相等的 $k$ 组成的集合。 推论 1：对任意长度为 $n$ 的字符串 $S$，有$$\\forall q \\in [2, n],\\pi[q] = \\begin{cases}0 &amp; E_{q - 1} = \\varnothing \\\\ 1 + \\max\\{k \\in E_{q - 1}\\} &amp; E_{q - 1} \\neq \\varnothing\\end{cases}$$ 证明 当 $E_{q - 1} = \\varnothing$ 时，不存在任何一个 $k \\in \\pi^{\\star}[q - 1]$，使得 $S_{k + 1} \\sqsupset S_q$。显然此时 $\\pi[q]$ 只能为 $0$。当 $E_{q - 1} \\neq \\varnothing$ 时，$\\forall k \\in E_{q - 1}, k &lt; q - 1 \\land S_{k + 1} \\sqsupset S_q \\Longrightarrow k + 1 &lt; q$则由 $\\pi[q]$ 的定义，$k$ 是拓展到 $S_q$ 的某一后缀的备选项，$\\pi[q] \\ge 1 + \\max\\{k \\in E_{q - 1}\\}$。注意到此时 $\\pi[q] &gt; 0$，设 $r = \\pi[q] - 1$。则 $r + 1 = \\pi[q] &lt; q, S_{r + 1} = S_{\\pi[q]} \\sqsupset S_q$。$\\because r + 1 &gt; 0$$\\therefore S_{r + 1} = S_q$由引理 3 可得 $r = \\pi[q] - 1 \\in \\pi^{\\star}[q - 1]$$\\therefore r \\in E_{q - 1}$$\\therefore \\pi[q] - 1 = r \\le \\max\\{k \\in E_{q - 1}\\}$即 $\\pi[q] \\le 1 + \\max\\{k \\in E_{q - 1}\\}$综上所述，当 $E_{q - 1} \\neq \\varnothing$，$\\pi[q] = 1 + \\max\\{k \\in E_{q - 1}\\}$。$\\blacksquare$ 再来看看代码： 1234567891011void calcPi(char* S) &#123; pi[1] = 0; int len = strlen(S + 1); for(int i = 2, k = 0; i &lt;= len; ++i) &#123; while(k &gt; 0 &amp;&amp; S[k + 1] != S[i]) k = pi[k]; if(S[k + 1] == S[i]) ++k; pi[i] = k; &#125;&#125; 接下来我们将使用循环不变式来证明上述代码的正确性。 证明 初始化在第 4 行的迭代开始前，有 $i = 1, k = \\pi[i] = 0$，不变式成立。保持在每次迭代开始前，有 $k = \\pi[i - 1]$：若是第一次迭代，此等式由第 4 行保证；其余迭代均由第 9 行保证。接下来要证明每次迭代结束后均有 $k = \\pi[i]$ 成立。若 $k \\neq \\pi[i]$，则会在第 5-8 行将 $k$ 调整至 $\\pi[i]$。第 5 行的 while 循环遍历每一个 $k \\in \\pi^{\\star}[i - 1]$，直至找到一个 $k$，使得 $S[k + 1] = S[i]$。（引理 2）若找不到这样的值，则在第 7 行 $k = 0$。若找到了这样的值，此时 $k$ 为满足条件的集合中的最大值，应将 $\\pi[i] \\gets k + 1$。（推论 1）第 9 行的赋值语句使得 $k = \\pi[i]$ 恒成立。终止当 $i = n + 1$ 时，迭代终止，此时我们求出了 $\\pi[1..n]$。至此，算法结束。因此，上述代码实现能正确地求出字符串 $S$ 的前缀函数数组。$\\blacksquare$ 时间复杂度不难发现，第 7-9 行代码的时间复杂度均为 $O(n)$，唯一棘手的是第 6-7 行代码。 考虑 $k$ 的变化，$k$ 在第 7-8 行增加的次数不超过 $n$ 次，即 $k \\le n$； $k$ 在第 6 行的操作中，因为有 $\\pi(S_i) &lt; i$ 的性质，导致每次迭代至少使 $k$ 减小 $1$，即最多迭代 $n$ 次。 综上所述，用上述方法求一个字符串的前缀函数数组的时间复杂度为 $O(n)$。 空间复杂度易知用此种方法求前缀函数数组的空间复杂度为 $O(n)$。 KMP 算法算法流程代码实现正确性时间复杂度空间复杂度应用写在最后","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"学习笔记/字符串","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://leverimmy.top/tags/KMP/"},{"name":"前缀函数","slug":"前缀函数","permalink":"https://leverimmy.top/tags/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0/"}]},{"title":"【CodeForces】CF1369C RationalLee","slug":"【CodeForces】CF1369C-RationalLee","date":"2020-06-24T05:51:10.000Z","updated":"2020-07-03T08:01:06.183Z","comments":true,"path":"2020/06/24/【CodeForces】CF1369C-RationalLee/","link":"","permalink":"https://leverimmy.top/2020/06/24/%E3%80%90CodeForces%E3%80%91CF1369C-RationalLee/","excerpt":"题意简述：给定 $n$ 个价值分别为 $a_i$ 的元素以及 $k$ 个容量分别为 $w_i$ 的背包，其中每个元素的体积均为 $1$。求每个背包内的最大价值与最小价值之和的和的最大值。 $1 \\le n, k \\le 2\\cdot 10^5$，保证 $\\sum w_i = n$。 题目链接","text":"题意简述：给定 $n$ 个价值分别为 $a_i$ 的元素以及 $k$ 个容量分别为 $w_i$ 的背包，其中每个元素的体积均为 $1$。求每个背包内的最大价值与最小价值之和的和的最大值。 $1 \\le n, k \\le 2\\cdot 10^5$，保证 $\\sum w_i = n$。 题目链接 解题思路：首先，将 $a, w$ 按降序排列。 当存在 $w_i = 1$ 时，从 $a$ 的较大头开始取 $1$ 个元素分给它。 其次，将剩下的元素分给其他的 $w$： 每个容量为 $w_i$ 的背包，从 $a$ 的较大头开始取 $1$ 个、从 $a$ 的较小端取 $w_i - 1$ 个，这样一定保证是最优的。 为什么这个策略是最优的？ 若把较大的 $a_i$ 分给容量大于 $1$ 的背包，显然那个背包的较小值不为 $a_i$，则 $a_i$ 只能被算一次； 但将 $a_i$ 分给容量为 $1$ 的背包，$a_i$ 将会被算两次，这样一定比某个 $a_j \\le a_i$ 的 $j$ 放入这个容量为 $1$ 的背包要不劣。 $a$ 从小往大考虑，最小的数一定会被放进某个背包，且这个背包的最小值一定是这个最小的数； 那么我们就应该尽量地消耗较小的数，从小到大把 $w_i - 2$ 个数也放进这个背包，并配上一个较大的数。 考虑排序后的 $a_n$ 与 $a_{n - 1}$： 显然 $a_{n - 1} \\le a_{n - 2}$，这导致令 $a_{n - 2}$ 为另一背包的最小元素一定要比 $a_{n - 1}$ 不劣，则我们就应该将 $a_{n - 1}$ 与 $a_n$ 放入同一背包而不是将 $a_{n - 2}$ 与 $a_n$ 放入同一背包。 剩下的 $a$ 同理。 总的时间复杂度为 $O(n\\log n)$。 参考代码： Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define LL long longnamespace io &#123; template &lt;typename T&gt; inline void read(T &amp; _x) &#123; int f = 0, ch; _x = 0; while(!isdigit(ch = getchar())) f |= ch == '-'; while(isdigit(ch)) _x = _x * 10 + ch - '0', ch = getchar(); if(f) _x = -_x; &#125; template &lt;typename T, typename ... Args&gt; inline void read(T &amp;_f, Args&amp; ... args) &#123; read(_f), read(args ...); &#125; inline void _deal(char ch) &#123; putchar(ch); &#125; template &lt;typename T&gt; inline void _deal(T _x) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; if (_x &gt; 9) _deal(_x / 10); putchar(_x % 10 + '0'); &#125; inline void write() &#123;&#125; template &lt;typename T, typename ... Args&gt; inline void write(T _f, Args ... args) &#123; _deal(_f), write(args...); &#125;&#125;const int inf = 0x3f3f3f3f;const int N = 2e5 + 5;const int K = 2e5 + 5;int n, k, a[N], w[K];int32_t main() &#123; int __tests; scanf(\"%d\", &amp;__tests); while(__tests--) &#123; io::read(n, k); LL ans = 0; for(int i = 1; i &lt;= n; ++i) io::read(a[i]); for(int i = 1; i &lt;= k; ++i) io::read(w[i]); std::sort(a + 1, a + n + 1, std::greater &lt;int&gt; ()); std::sort(w + 1, w + k + 1, std::greater &lt;int&gt; ()); int l = 1, r = n, ones = 0; for(int i = k; i &gt;= 1; --i) &#123; if(w[i] &gt; 1) break; ans += a[l] * 2; ++l, ++ones; &#125; for(int i = 1; i &lt;= k - ones; ++i) &#123; ans += a[l] + a[r]; ++l, r -= (w[i] - 1); &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"CodeForces","slug":"题解/CodeForces","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/CodeForces/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://leverimmy.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"排序","slug":"排序","permalink":"https://leverimmy.top/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"【学习笔记】EERTREE 学习笔记","slug":"【学习笔记】EERTREE-学习笔记","date":"2020-06-22T14:51:07.000Z","updated":"2020-07-03T05:43:21.917Z","comments":true,"path":"2020/06/22/【学习笔记】EERTREE-学习笔记/","link":"","permalink":"https://leverimmy.top/2020/06/22/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91EERTREE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"EERTREE，又称回文树（Palindrome tree）、回文自动机（PAM），是一种能在 $O(\\left|S\\right|\\log{\\left|\\Sigma\\right|})$ 的时间与 $O(\\left|S\\right|)$ 的空间内处理与 回文串 有关问题的数据结构。 EERTREE 是一个 回文串，也许这就是这个数据结构的名字的来历。 回文树的高级应用慢慢写，持续更新。 pdf 论文","text":"EERTREE，又称回文树（Palindrome tree）、回文自动机（PAM），是一种能在 $O(\\left|S\\right|\\log{\\left|\\Sigma\\right|})$ 的时间与 $O(\\left|S\\right|)$ 的空间内处理与 回文串 有关问题的数据结构。 EERTREE 是一个 回文串，也许这就是这个数据结构的名字的来历。 回文树的高级应用慢慢写，持续更新。 pdf 论文 写在前面为了更方便地描述字符串相关内容，我们做出以下规定： $S, T$ 通常表示一个字符串，$c$ 通常表示一个字符，$\\Sigma$ 表示字符集； $\\left|S\\right|$ 表示字符串长度； $\\left|\\Sigma\\right|$ 表示字符集大小； $S[l..r]$ 表示 $S[l], S[l + 1], \\ldots, S[r - 1], S[r]$； $\\epsilon$ 表示空串； $S \\subset T$ 表示 $S$ 为 $T$ 的子串，即 $\\exists i \\in [1, \\left|T\\right| - \\left|S\\right|], \\text{s.t. } \\forall j \\in [1, \\left|S\\right|], S[j] = T[i + j - 1]$； $\\overleftarrow{S}$ 表示 $S$ 的翻转，即 $\\forall i \\in [1, \\left|S\\right|], \\overleftarrow{S[i]} = S[\\left|S\\right|- i + 1]$； $S$ 为回文串当且仅当 $S = \\overleftarrow{S}$，即 $\\forall i \\in [1, \\left|S\\right|], S[i] = S[\\left|S\\right| - i + 1]$； 若 $S$ 为回文串，则定义 $r(S)$ 为其最长回文半径，即 $r(S) = \\max\\{\\left\\lfloor\\dfrac{\\left|T\\right| + 1}{2}\\right\\rfloor\\}, T \\subset S, T = \\overleftarrow{T}$。 特殊地，本文的字符串下标、回文树内节点编号 均从 $1$ 开始。 一些例子：对于 $S = \\mathtt{ABCBAD}$ 而言： $\\left|S\\right| = 6$； $\\left|\\Sigma\\right| = 4$； $S[2..4] = \\mathtt{BCBA}$； $S[1..4] \\subset S[1..5]$； $\\overleftarrow{S[3..5]} = \\mathtt{DAB}$； $S[1..5] = \\mathtt{ABCBA} = \\overleftarrow{S[1..5]}$ 为回文串。 结构、操作与建立为什么我们考虑一个长度为 $n$ 的回文串 $S$，令 $P = { T : T = S[i..n - i + 1] \\quad i \\in [1, \\left\\lfloor\\dfrac{n + 1}{2}\\right\\rfloor]}$，则 $\\forall x \\in P, x = \\overleftarrow{x}$。 那么 $\\forall x \\in P$ 之间又有什么样的关系呢？ 不难发现，一个回文串，是很多 子回文串层层嵌套 而成的。 也就是说，一个回文串，通过 在两端添加相同的字符，可以形成一个新的回文串。 至此，我们寻觅到了回文树上 边的意义。 在回文树中，$u$ 的父亲连向 $u$ 的边上存储着字符 $c$ 的意义是 $u$ 的父亲表示的回文串，在两端加上 $c$ 后，能形成 $u$。 是什么 引理 1：向 $S$ 末尾添加一个字符 ，最多只会新生成一个回文子串。 证明 这个子串是 $S$ 的 最长回文后缀 末端增加 $c$，且原来的前端恰好也是 $c$，所产生的。也就是说，每次在 $S$ 的末尾添加一个字符，最多只会新建一个节点。$\\blacksquare$ 回文树的内部结构，是一个包含着额外信息的有向图。 在后文中，我们可能会用回文子串来表示一个节点。 回文树支持两个操作：$\\text{add}(c)$ 和 $\\text{eertree}(S)$。 $\\text{add}(c)$ 表示在回文树内插入 $c$，返回此次操作新增的回文子串个数。 通过引理 1，我们可以知道 $\\text{add}(c)$ 总是返回 $0$ 或 $1$。 不难发现，每次 $\\text{add}$ 操作之后，我们都能在 $O(1)$ 的时间内得到已经处理了的字符串 $T$ 的最长回文后缀，即 $\\text{maxSuf}(T)$。 $\\text{eertree}(S)$ 表示将 $S$ 内的字符，从左至右逐个插入后形成的回文树。 小结 1：$S$ 中包含的本质不同的回文子串数量为 $\\text{eertree}(S)$ 的节点中的最大编号。 一棵回文树上的每一个节点上要存储的信息有： 这个点的序号 $u$； 表示的回文串的长度 $len_u$； 从这个点出发的一条标为 $c$ 的出边指向的节点的编号 $ch_{u, c}$； 回文链接 $fail_u$； 为了以后的方便，我们需要在初始化的时候新建两个节点，长度和编号分别为 $-1$ 和 $0$。 $0$ 表示着空串，称之为「偶根」；而 $-1$ 表示着「虚串」，称之为「奇根」。 偶根（即 $0$）连出的边（如果存在），指向 $cc$，表示在 $\\epsilon$ 的两侧同时添加 $c$ 所形成的的字符串为 $cc$； 奇根（即 $-1$）连出的边（如果存在），指向 $c$，表示原来长度为 $-1$ 的串，在两侧同时添加 $c$ 形成了长度为 $1$ 的字符串 $c$。 节点 $u$ 连至 $v$ 的回文链接 $fail_u$ 意味着 $v$ 表示的回文串 $S$ 是 $u$ 表示的回文串 $T$ 的次长回文后缀子串（因为最长的是自己本身）。 我们 定义 $fail_c = 0, fail_0 = fail_{-1} = -1$。 引理 2：任一满足 $len_u &gt; 0$ 的节点 $u$ 的入度为 $1$（注意，这里的「入度」不将「后缀链接」计算在内）。 证明 若 $len_u = 1$，则其唯一的入边必为 $-1 \\to u$；若 $len_u = 2$，则其唯一的入边必为 $0 \\to u$；若 $len_u \\ge 3$，则其唯一的入边必为 $v \\to u$，满足：$v$ 表示的回文子串 $T$ 的两端添加某个字符 $c$ 能使得 $u$ 表示的回文子串 $S$ 满足 $S = cTc$。综上所述，任一满足 $len_u &gt; 0$ 的节点 $u$ 的入度为 $1$。$\\blacksquare$ 命题 1：建立一个长度为 $n$ 的字符串 $S$ 的回文树 $\\text{eertree}(S)$ 的空间复杂度为 $O(n)$。 证明 由引理 1 可知，在 $S$ 的逐步插入过程中，最多会新建 $n$ 个节点；而还有 $2$ 个初始化时新建的节点。所以节点个数为最多为 $n + 2$ 个。由引理 2 可知，边的个数最多为 $n$ 个；后缀链接最多有 $n$ 个。综上所述，建立 $\\text{eertree}(S)$ 的空间复杂度为 $O(n)$。$\\blacksquare$ 怎么做以 $S_0 = \\mathtt{EERTREE}$ 为例，我们对它建立一棵回文树。 首先，我们先新建两个点，钦定它们为「奇根 $1$」和「偶根 $0$」。 一棵空的回文树是这样的（红色边为 $fail$ 边，蓝色边为 $ch$ 边，后同）： 然后我们插入 $\\mathtt{E}$，现在 $S = \\mathtt{E}$。 接着我们插入 $\\mathtt{E}$，现在 $S = \\mathtt{EE}$。 接着我们插入 $\\mathtt{R}$，现在 $S = \\mathtt{EER}$。 接着我们插入 $\\mathtt{T}$，现在 $S = \\mathtt{EERT}$。 接着我们插入 $\\mathtt{R}$，现在 $S = \\mathtt{EERTR}$。 接着我们插入 $\\mathtt{E}$，现在 $S = \\mathtt{EERTRE}$。 接着我们插入 $\\mathtt{E}$，现在 $S = \\mathtt{EERTREE}$。 我们应该如何实现这个过程呢？ 命题 2：建立一个长度为 $n$ 的字符串 $S$ 的回文树 $\\text{eertree}(S)$ 的时间复杂度可达到在线 $O(n\\log\\left|\\Sigma\\right|)$。 证明 在初始化的时候，我们得到了 $\\text{eertree}(\\epsilon)$，即一个「奇根」和一个「偶根」加上它们的后缀链接。对 $S$ 建造回文树的时候，我们会依次向回文树中插入 $S[1], S[2], \\ldots, S[n]$。我们要使得在每次 $\\text{add}$ 操作之后，回文树中的所有节点之间的边以及回文链接都被正确维护。考虑进行完了第 $i$ 次操作后的状态，也就是我们已经处理了 $T = S[1, i]$ 的回文树，现在要插入 $c = S[i + 1]$。我们现在的目标是寻找 $S[1..i + 1] = Tc$ 的最长回文后缀 $P$。显然，要么 $P = c$，要么 $P = cQc$（显然 $Q$ 为 $S[1..i]$ 的某一回文后缀）。也就是说，我们需要找到 $T$ 中，以 开头的前一位 为 $c$ 的最长回文后缀 $Q$。我们从 $\\text{maxSuf}(T)$ 开始，沿着回文链接遍历，设当前节点为 $v$，比较 $c$ 和 $T[i - len_v - 1]$。怎么理解呢？$T[i - len_v..i - 1]$ 是某一回文串 $Q$，我们要找的，是满足 $Q$ 开头的前一位为 $c$ 的某一回文串。也就是要保证 $c = T[i - len_v - 1]$。不难发现，特殊地，当 $P = c$ 时，$Q$ 对应的节点为「奇根」。若 $P = c$：检查 $ch_{-1, c}$ 是否存在：若不存在，则新建一个节点 $v$，使 $ch_{-1, c} = v, len_v = 1, fail_v = 0$。若存在，根据定义，$fail_v = 0$ 不需要更新。若 $P = cQc$：设 $Q$ 对应的节点的序号为 $u$。检查 $ch_{u, c}$ 是否存在：若不存在，则新建一个节点 $v$，使 $len_v = len_u + 2$，连接 $u \\to v$，还要更新 $fail_v$。若存在，我们只需要考虑更新 $fail_v$。考虑 $fail_v$ 到底会指向哪里？会指向 $S[1, i + 1] = Tc$ 的次长回文后缀。即 $cQc$ 中 开头的前一位 为 $c$ 的次长回文后缀 $R$。若我们从 $u$ 开始遍历后缀链接，那么找到的会是 $cQc$ 这个最长回文后缀；因此我们应从 $fail_u$ 开始遍历，仍然是比较 $c$ 和 $T[i - len_v - 1]$。接下来我们来分析 $\\text{add}$ 操作的时间复杂度。我们每次检查 $ch_{u, c}$（或是检查 $ch_{-1, c}$）是否存在，需要 $O(\\log\\left|\\Sigma\\right|)$ 的时间复杂度（std::map 之类的数据结构实现）实际情况下，我们使用子节点数组来实现，单次 $\\text{add}$ 的时间复杂度是 $O(\\left|\\Sigma\\right|)$ 的。则一共 $n$ 次，共 $O(n \\log\\left|\\Sigma\\right|)$。令已经处理了的字符串 $S[1..i] = T$，考虑 $\\text{maxSuf}(T)$ 的末尾在 $S$ 中的下标 $j$ 的变化：一个 $fail$ 的转移会使 $j$ 向左至少移动 $1$ 格；一个 $ch$ 转移会使 $j$ 向右至少移动一格。在处理整个 $S$ 的过程中，向左最多移动 $n$ 格，也就是最多 $n$ 次；向右最多移动 $n$ 格，也就是最多 $n$ 次。因此转移部分的时间复杂度为总共 $O(n)$。总时间复杂度为 $O(n) + O(n\\log\\left|\\Sigma\\right|) = O(n\\log\\left|\\Sigma\\right|)$。综上所述，建立一个长度为 $n$ 的字符串 $S$ 的回文树 $\\text{eertree}(S)$ 的时间复杂度可达到在线 $O(n\\log\\left|\\Sigma\\right|)$。$\\blacksquare$ 代码实现后文有吧。 性质我们称一个节点 $u$ 是「奇」的，当且仅当 $len_u$ 为奇数；称一个节点 $v$ 是「偶」的，当且仅当 $len_v$ 为偶数。 引理 3：一棵回文树本质上是两个弱连通图：以「奇根」和「奇点」构成的一个弱连通子图和以「偶根」和「偶点」构成的一个弱连通子图，且均为树。「奇点」和与其相连的边构成的树是 $S$ 右半部分长度为奇数的回文子串构成的 trie；「偶点」和与其相连的边构成的树是 $S$ 右半部分长度为偶数的回文子串构成的 trie。一棵回文树中的所有节点与连接在每个节点上的回文链接的反向链接构成一棵有向基环树，其中环为 $-1$ 节点的自环。 证明 如果边 $e = u \\to v$ 存在，则 $len_v = len_u + 2$，显然 $u, v$ 奇偶性相同，则「奇点」与「偶点」之间互不相通。结合引理 2，此性质得证。这是回文树上边的定义和 trie 的定义。注意到，除了 $fail_{-1}$，其他的回文链接均会使 $len$ 减小，且回文树中的每个点均有唯一的后缀链接。则每个点都仅有唯一简单路径到达 $-1$，这显然是一棵（带有一个环）的树。$\\blacksquare$ 小结 2：一些基本的字符串数据结构如回文 trie、后缀 trie 的空间复杂度都是 $O(n^2)$ 的；像后缀树和 Compressed trie 这样很复杂的数据结构空间复杂度是 $O(n)$ 的。但回文树这么简明易懂的数据结构的空间复杂度也是 $O(n)$ 的。岂不妙哉？ 更重要的是，一个字符串中本质不同的回文串期望个数 是 $O(\\sqrt{\\left|S\\right|\\cdot\\left|\\Sigma\\right|})$ 的。也就是说，回文树的期望空间复杂度更佳。 小结 3：我们定义一个映射 $\\theta :\\Sigma \\to \\Sigma, \\text{s.t. } \\theta^2(S) = S$。我们称一个字符串 $S$ 是 $\\theta$-回文的，当且仅当 $S = \\theta(\\overleftarrow{S})$。一个长度为 $n$ 的字符串 $S$ 的 $\\theta$-回文树仍可以在 $O(\\left|S\\right|\\log{\\left|\\Sigma\\right|})$ 的时间与 $O(\\left|S\\right|)$ 的空间内建立起来。 基础应用 「APIO2014」回文串 题意：给定一个长度为 $n$ 的字符串 $S$，求 $\\max\\{\\left|T\\right|\\cdot \\text{occ}(S, T)\\}, T \\subset S \\land T = \\overleftarrow{T}$。 其中 $\\text{occ}(S, T)$ 表示 $T$ 在 $S$ 中的出现次数，$1 \\le \\left|S\\right| \\le 3 \\cdot 10^5$。 「MIPT Fall Programming Training Camp2014」B. Pairs 题意：给定一个长度为 $n$，字符集为 $\\Sigma$ 的字符串 $S$，求满足 $1 \\le i \\le j &lt; k \\le n \\land (S[i..j] = \\overleftarrow{S[i..j]}) \\land (S[j + 1..k] = \\overleftarrow{S[j + 1..k]})$ 的三元组 $(i, j, k)$ 的个数。 $1 \\le n \\le 3 \\cdot 10^5$ 性质 3：「APIO2014」回文串 能用回文树在 额外 $O(n)$ 的时间和空间 内解决。 证明 令 $\\text{occ}[u]$ 表示节点 $u$ 对应的字符串 $T$ 在 $S$ 中的出现次数。令 $\\text{occAsMax}[u]$ 表示满足 $\\text{maxSuf}(S[1, i]) = T$ 的 $i$ 的个数，这个可以直接在每次 $\\text{add}$ 之后实时维护。不难发现，$$\\text{occ}[u] = \\text{occAsMax}[u] + \\sum_{v:fail_v = u}\\text{occ}[v]$$因为，$T$ 在 $S$ 中出现，要么是以 $T = \\text{maxSuf}(S[1..i])$ 的形式出现，要么是以 $T = \\text{maxSuf}(S[l..r]), S[l..r] = \\overleftarrow{S[l..r]}$ 的形式出现。考虑到前者即 $\\text{occAsMax}[u]$，后者即满足 $fail_v = u$ 的 $\\text{occ}[v]$，则上述式子成立。由引理 3 可知，我们可以自底向上地维护 $\\text{occ}[u]$。（maxNode 是最大节点编号）1234for(int i = maxNode; i &gt;= 1; --i) occ[i] = occAsMax[i];for(int i = maxNode; i &gt;= 1; --i) occ[ fail[i] ] += occ[i];我们得到了 $\\text{occ}$ 之后，答案即为 $\\mathop{\\operatorname{argmax}}\\limits_{\\text{occ}[u]}(\\text{occ}[u]\\cdot len_u)$。不难发现，这额外维护的一部分时间复杂度和空间复杂度均为 $O(n)$。在实现的过程中，因为 C++ 不支持访问负数数组下标，所以我们 整体把下标加一，即 $0$ 代表「奇根」，$1$ 代表「偶根」……以此类推。此时 maxNode 即为 cntNode - 1，$1$ 号节点的编号实际上为 $2$（处理 $\\text{occ}$ 的时候要注意）。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;#define LL long longconst int N = 3e5 + 5;const int C = 26 + 5;int m;char str[N];struct EERTREE &#123; static const int MS = N; int n, cntNode, last, s[MS], len[MS], ch[MS][C], fail[MS]; int occAsMax[MS], occ[MS]; int make(int ll) &#123; len[cntNode] = ll; for(int i = 0; i &lt; C; ++i) ch[cntNode][i] = 0; return cntNode++; &#125; int getfail(int x) &#123; while(s[n] != s[n - len[x] - 1]) x = fail[x]; return x; &#125; bool add(int x) &#123; s[++n] = x; int u = getfail(last), flg = 0; if(!u) &#123; if(!ch[u][x]) &#123; int v = make(1); ch[u][x] = v; fail[v] = 1; flg = 1; &#125; &#125; else &#123; if(!ch[u][x]) &#123; int v = make(len[u] + 2); ch[u][x] = v; flg = 1; &#125; fail[ ch[u][x] ] = ch[getfail(fail[u])][x]; &#125; last = ch[u][x]; ++occAsMax[last]; return flg; &#125; LL getocc() &#123; LL ans = -1; // 这里要注意迭代的范围 for(int i = cntNode - 1; i &gt;= 2; --i) occ[i] = occAsMax[i]; for(int i = cntNode - 1; i &gt;= 2; --i) occ[ fail[i] ] += occ[i]; for(int i = cntNode - 1; i &gt;= 2; --i) ans = std::max(ans, 1LL * occ[i] * len[i]); return ans; &#125; void init() &#123; n = cntNode = last = 0; make(-1), make(0); &#125;&#125; t;int main() &#123; scanf(\"%s\", str + 1); m = strlen(str + 1); t.init(); for(int i = 1; i &lt;= m; ++i) t.add(str[i] - 'a' + 1); printf(\"%lld\", t.getocc()); return 0;&#125;$\\blacksquare$ 性质 4：「MIPT Fall Programming Training Camp2014」B. Pairs 能用回文树在 额外 $O(n\\log\\left|\\Sigma\\right|)$ 的时间和 $O(n)$ 的空间 内解决。 证明 首先，我们建立起 $\\text{eertree}(S)$。我们用 $\\text{maxSuf}[i]$ 来表示 $\\text{maxSuf}(S[1..i])$，这个显然能在 $O(n)$ 的空间内在每次 $\\text{add}$ 操作之后维护。我们令 $\\text{sufCount}[u]$ 表示编号为 $u$ 的节点对应的字符串的回文后缀的个数。同理我们还要求出 $\\text{maxPre}$ 与 $\\text{preCount}$。注意到它们分别对应的是 $\\overleftarrow{S}$ 的 $\\text{maxSuf}$ 和 $\\text{sufCount}$（记为 $\\text{maxSuf}’$ 和 $\\text{sufCount}’$。。于是，我们建立起 $\\text{eertree}(\\overleftarrow{S})$。答案即为$$\\sum_{i = 1}^{n - 1}\\text{sufCount}[\\text{maxSuf}[i]]\\cdot\\text{sufCount}’[\\text{maxSuf}’[n - i]]$$不难发现这部分的时间复杂度是 $O(n\\log\\left|\\Sigma\\right|)$ 的，空间复杂度是 $O(n)$ 的。md 没得地方交这道题，代码仅供参考。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define LL long longconst int N = 3e5 + 5;const int C = 26 + 5;int m;char str[N];LL ans;struct EERTREE &#123; static const int MS = N; int n, cntNode, s[MS], len[MS], ch[MS][C], fail[MS]; int sufCount[MS], maxSuf[MS]; int make(int ll) &#123; len[cntNode] = ll; for(int i = 0; i &lt; C; ++i) ch[cntNode][i] = 0; return cntNode++; &#125; int getfail(int x) &#123; while(s[n] != s[n - len[x] - 1]) x = fail[x]; return x; &#125; bool add(int x) &#123; s[++n] = x; int u = getfail(maxSuf[n - 1]), flg = 0; if(!u) &#123; if(!ch[u][x]) &#123; int v = make(1); fail[v] = 1; ch[u][x] = v; flg = 1; &#125; &#125; else &#123; if(!ch[u][x]) &#123; int v = make(len[u] + 2); ch[u][x] = v; flg = 1; &#125; fail[ ch[u][x] ] = ch[getfail(fail[u])][x]; &#125; sufCount[ch[u][x]] = sufCount[ fail[ch[u][x]] ] + 1; maxSuf[n] = ch[u][x]; return flg; &#125; void init() &#123; n = cntNode; memset(maxSuf, 0, sizeof(maxSuf)); make(-1), make(0); &#125;&#125; t1, t2;int main() &#123; scanf(\"%s\", str + 1); m = strlen(str + 1); t1.init(), t2.init(); for(int i = 1; i &lt;= m; ++i) t1.add(str[i] - 'a' + 1); for(int i = m; i &gt;= 1; --i) t2.add(str[i] - 'a' + 1); for(int i = 1; i &lt;= m - 1; ++i) ans += t1.sufCount[ t1.maxSuf[i] ] * t2.sufCount[ t2.maxSuf[m - i] ]; printf(\"%lld\", ans); return 0;&#125;$\\blacksquare$ 高级应用并回文树与多个串的回文串相关的问题，我们可以用 并回文树 来解决。 我们用 $\\text{eertree}(S_1, S_2, \\ldots, S_n)$ 表示 $S_1, S_2, \\ldots, S_n$ 的并回文树。 支持删除的回文树富字符串计数可持久化回文树写在最后回文树真的能很巧妙地解决与回文串有关的问题， 而且很多与回文串有关的问题的暴力的时间复杂度极劣无比， 这也能从侧面体现出回文树的巧妙。 与字符串有关的数据结构都巧夺天工。 用一首前人写的诗作结尾： $$\\begin{aligned} &amp; \\textit{I think that I shall never see} \\\\ &amp; \\textit{A poem lovely as a tree.} \\\\ &amp; \\textit{Poems are made by fools like me,} \\\\ &amp; \\textit{But only God can make a tree.}\\end{aligned}$$ 接下来就开始努力钻研后缀树吧。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"学习笔记/字符串","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"回文树","slug":"回文树","permalink":"https://leverimmy.top/tags/%E5%9B%9E%E6%96%87%E6%A0%91/"}]},{"title":"【AtCoder】ABC171F Strivore","slug":"【AtCoder】ABC171F-Strivore","date":"2020-06-22T04:17:56.000Z","updated":"2020-07-03T07:59:01.791Z","comments":true,"path":"2020/06/22/【AtCoder】ABC171F-Strivore/","link":"","permalink":"https://leverimmy.top/2020/06/22/%E3%80%90AtCoder%E3%80%91ABC171F-Strivore/","excerpt":"题意简述：给定一个字符串 $S$ 和数字 $k$，求所有本质不同的字符串 $T$ 的个数，使得 $\\left|T\\right| = \\left|S\\right| + k$，且 $S$ 为 $T$ 的子序列。 $1 \\le \\left|S\\right|, k \\le 10^6$。 题目链接","text":"题意简述：给定一个字符串 $S$ 和数字 $k$，求所有本质不同的字符串 $T$ 的个数，使得 $\\left|T\\right| = \\left|S\\right| + k$，且 $S$ 为 $T$ 的子序列。 $1 \\le \\left|S\\right|, k \\le 10^6$。 题目链接 解题思路： 令 $n = \\left|S\\right|, m = \\left|S\\right| + k$。 正着计算 $S$ 为 $T$ 的子序列时 $T$ 的个数不方便，因此我们可以考虑计算 $S$ 不为 $T’$ 的子序列时 $T’$ 的个数。 再用 $26^m$ 减去 $T’$ 的个数，即为 $T$ 的个数。 $T’$ 中可能包含 $S$ 的前缀 $S[1], S[1\\ldots2], S[1\\ldots3], \\cdots, S[1\\ldots n - 1]$； 当然，也可能不包含 $S$ 的任意一个前缀，可以看做包含 $S[1\\ldots0] = \\epsilon$。 当 $T’$ 中包含 $S[1\\ldots i] \\quad i \\in [0, n)$ 时，从 $m$ 个位置里选取 $i$ 个位置来填这些字符有 $\\dbinom{m}{i}$ 种方法， 而要求剩下的 $m - i$ 个位置不能使 $T$ 包含 $S[1\\ldots i + 1]$，因此有 $25^{m - i}$ 种方法。 因此答案为$$26^{m}-\\sum_{i = 0}^{n - 1}\\binom{m}{i}\\cdot25^{m - i}$$值得一提的是，此题的答案与 $S$ 具体是什么无关，只与 $\\left|S\\right|$ 有关。 参考代码： Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define LL long longconst int mod = 1e9 + 7;const int N = 1e6 + 5;const int M = 2e6 + 5;int n, k;int m, fac[M] = &#123; 1 &#125;, inv[M];char str[N];LL tot, mis;int mul(int ta, int tb) &#123; int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(ta), \"b\"(tb), \"c\"(mod)); return ret;&#125;int qpow(int bas, int po) &#123; int res = 1; while(po) &#123; if(po &amp; 1) res = mul(res, bas); bas = mul(bas, bas); po &gt;&gt;= 1; &#125; return res;&#125;int C(int tn, int tm) &#123; return mul(fac[tn], mul(inv[tm], inv[tn - tm]));&#125;int32_t main() &#123; scanf(\"%d %s\", &amp;k, str + 1); n = strlen(str + 1); m = n + k; tot = qpow(26, m); for(int i = 1; i &lt;= m; ++i) fac[i] = mul(fac[i - 1], i); for(int i = 0; i &lt;= m; ++i) inv[i] = qpow(fac[i], mod - 2); for(int i = 0; i &lt;= n - 1; ++i) &#123; mis = (mis + mul(C(m, i), qpow(25, m - i))) % mod; &#125; tot = ((tot - mis) % mod + mod) % mod; printf(\"%d\", tot); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://leverimmy.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"快速幂","slug":"快速幂","permalink":"https://leverimmy.top/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"容斥","slug":"容斥","permalink":"https://leverimmy.top/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"【游记】HBOI2020 游记","slug":"【游记】HBOI2020-游记","date":"2020-06-19T14:19:16.000Z","updated":"2020-07-03T08:10:46.217Z","comments":true,"path":"2020/06/19/【游记】HBOI2020-游记/","link":"","permalink":"https://leverimmy.top/2020/06/19/%E3%80%90%E6%B8%B8%E8%AE%B0%E3%80%91HBOI2020-%E6%B8%B8%E8%AE%B0/","excerpt":"呐，又到了省选季了呢。","text":"呐，又到了省选季了呢。 Day 0上午还是依然在家里上学校的网课，《廉颇蔺相如列传》中的侧面烘托好妙啊…… 下午去学校试机，打了个 PAM，显然不会考（但我也不会其他的了） 真的一个月埋在文化课的苦海里啊……这个月好像只打了几场 cf，啥东西也没学。 成功在学校面基到了自己的同学（大雾 已经半年没有见面了……寒假上一次见面是一月下旬吧。 晚上在家里打了一下 splay 板子，复习了一下 dinic，发现洛谷上的「普通平衡树（加强版）」好毒瘤啊……过不去。 然后就洗洗睡了。 明天也许拿三个题的第一档暴力分吧（运气好能拿第二档吧？）。 Day 1早上差点睡过头了，六点二十才起来。于是在车上眯了一会儿，没睡多久就到学校了。 在大门，保安把我拦住了，问我是干嘛的，发现才 7:20。 把准考证给他看了他就放我进去了。我很不相信那个测体温的东西是否准确，我总觉得红外测温会有很大误差吧。 到的太早了，先去自己的机房里坐了一会儿，不让进考场机房。 到时间了才进考场，抽到了序号最大的机子（暗示垫底），8:25 准时开题。 T1 是个数据结构，T2 是个数论，T3 是不知道啥玩意。 T1 先写了第一档的暴力 10pts，然后发现第二档答案单调不减，随便写了写就跟暴力拍过了。 后面的 2e5 感觉可以维护前后缀和来解决，先放着。 T2 前两个档都能拿到，第一档 p 不是质数，就预处理组合数来解决；第二档直接费马小定理推逆元。 后面的档感觉不会做。 T3 看了几眼，搜都不想搜。 考完了要我们待在另外一个机房等着，然后一堆队爷在讨论题目，我不会；zzy 切了 t2（Orz） 然后每五个人回到考场机房看自己的代码有没有收漏的，不一会儿就解放了。 下午 2:00 才吃到午饭，饿死了；然后睡大觉直到 17:00 才起来。 晚上随便打了点代码，就睡了。 奶明天字符串和网络流。 Day 2去学校还是很早，然后在自己的机房里水了水洛谷之类的，玩了下 QQ，然后就去抽签了。 一遍过压缩包密码，非常舒服。 开了题后的我：？为啥不考字符串啊？（考了我也不会） T1 是个状压，T2 是个数据结构，T3 是个计数。 T1 写了暴力 30pts。 T2 只会 10pts 的暴力，发现问题可以用 dfs 序转化为区间加一，区间异或和，但我不会，爬了。 T3 只会 30pts 的暴力，不会图的生成树计数，爬了。 然后发现外高这次考得不好。 晚上补周五到周日的文化课了，完全没有状态。 周四的时候能随便切的物理实验题完全不会了，找不着感觉，枯了。 Day 4出成绩了吧。 滚粗。","categories":[{"name":"杂笔","slug":"杂笔","permalink":"https://leverimmy.top/categories/%E6%9D%82%E7%AC%94/"},{"name":"游记","slug":"杂笔/游记","permalink":"https://leverimmy.top/categories/%E6%9D%82%E7%AC%94/%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"HBOI2020","slug":"HBOI2020","permalink":"https://leverimmy.top/tags/HBOI2020/"}]},{"title":"【学习笔记】类欧几里得算法学习笔记","slug":"【学习笔记】类欧几里得算法学习笔记","date":"2020-05-04T08:27:33.000Z","updated":"2020-07-03T08:14:52.791Z","comments":true,"path":"2020/05/04/【学习笔记】类欧几里得算法学习笔记/","link":"","permalink":"https://leverimmy.top/2020/05/04/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"「类欧几里得算法」与「欧几里得算法」的共同之处—— 仅是均使用了「辗转相除」来证明复杂度。","text":"「类欧几里得算法」与「欧几里得算法」的共同之处—— 仅是均使用了「辗转相除」来证明复杂度。 简介已知 $a, b, c, n$，求 $$\\begin{aligned} f(a, b, c, n) &amp; = \\sum_{i = 0}^{n}\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor \\\\ g(a, b, c, n) &amp; = \\sum_{i = 0}^{n}\\left(i\\cdot\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right) \\\\ h(a, b, c, n) &amp; = \\sum_{i = 0}^{n}\\left(\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right)^2\\end{aligned}$$ 共 $t (1 \\le t \\le 10^5)$ 组数据，$0 \\le a, b, c, n \\le 10^9$，$c \\neq 0$。 理论推导推导之前记 $m = \\left\\lfloor\\dfrac{an + b}{c}\\right\\rfloor, t = \\left\\lfloor\\dfrac{cj + c - b - 1}{a}\\right\\rfloor$，下文的方括号均为 艾佛森括号。 在推式子之前，我们先要证明一个常用的结论。 $$\\begin{aligned} \\sum_{j = 0}^{m - 1}\\sum_{i = 0}^{n}\\left[j &lt; \\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right] = \\sum_{j = 0}^{m - 1}\\sum_{i = 0}^{n}\\left[i &gt; t\\right]\\end{aligned}$$ 证明 注意到$$\\begin{aligned} j &lt; \\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor &amp; \\Leftrightarrow j + 1 \\le \\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor \\\\ &amp; \\Leftrightarrow j + 1 \\le \\dfrac{ai + b}{c} \\\\ &amp; \\Leftrightarrow cj + c \\le ai + b \\\\ &amp; \\Leftrightarrow cj + c - 1 &lt; ai + b \\\\ &amp; \\Leftrightarrow cj - b + c - 1 &lt; ai \\\\ &amp; \\Leftrightarrow i &gt; \\left\\lfloor\\dfrac{cj + c - b - 1}{a}\\right\\rfloor \\\\ &amp; \\Leftrightarrow i &gt; t\\end{aligned}$$所以原命题得证。 f首先我们来求 $f(a, b, c, n)$ 的递推式。 我们 定义 $f(a, b, c, n) = \\sum_{i = 0}^{n}\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor$。 当 $a \\ge c$ 或 $b \\ge c$ 时： $$\\begin{aligned} f(a, b, c, n) &amp; = \\sum_{i = 0}^{n}\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor \\\\ &amp; = \\sum_{i = 0}^{n}\\left\\lfloor\\dfrac{\\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot c + a \\bmod c\\right) \\cdot i + \\left(\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\cdot c + b \\bmod c\\right)}{c}\\right\\rfloor \\\\ &amp; = \\sum_{i = 0}^{n}\\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot i + \\left\\lfloor\\dfrac{b}{c}\\right\\rfloor + \\left\\lfloor\\dfrac{\\left(a \\bmod c\\right) \\cdot i + \\left(b \\bmod c\\right)}{c}\\right\\rfloor\\right) \\\\ &amp; = \\left(\\sum_{i = 0}^{n}\\left\\lfloor\\dfrac{\\left(a \\bmod c\\right) \\cdot i + \\left(b \\bmod c\\right)}{c}\\right\\rfloor\\right) + \\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot\\sum_{i = 0}^{n}i\\right) + \\left(\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\cdot\\sum_{i = 0}^{n}1\\right)\\\\ &amp; = f(a \\bmod c, b \\bmod c, c, n) + \\dfrac{n(n + 1)}{2}\\cdot\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor + (n + 1)\\cdot\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\end{aligned}$$ 当 $a &lt; c$ 且 $b &lt; c$ 时： $$\\begin{aligned} f(a, b, c, n) &amp; = \\sum_{i = 0}^{n}\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor \\\\ &amp; = \\sum_{i = 0}^{n}\\sum_{j = 0}^{\\left\\lfloor\\tfrac{ai + b}{c}\\right\\rfloor - 1}1 \\\\ &amp; = \\sum_{i = 0}^{n}\\sum_{j = 0}^{m - 1}\\left[j &lt; \\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right] \\\\ &amp; = \\sum_{j = 0}^{m - 1}\\sum_{i = 0}^{n}\\left[j &lt; \\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right] \\\\ &amp; = \\sum_{j = 0}^{m - 1}\\sum_{i = 0}^{n}\\left[i &gt; t\\right] \\\\ &amp; = \\sum_{j = 0}^{m - 1}\\left(n - t\\right) \\\\ &amp; = \\sum_{j = 0}^{m - 1}n + \\sum\\limits_{j = 0}^{m - 1}\\left\\lfloor\\dfrac{cj + (c - b - 1)}{a}\\right\\rfloor \\\\ &amp; = nm - f(c, c - b - 1, a, m - 1)\\end{aligned}$$ 综上所述，我们得到了 $f$ 的递推式： $$f(a, b, c, n) =\\begin{cases}f(a \\bmod c, b \\bmod c, c, n) + \\dfrac{n(n + 1)}{2}\\cdot\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor + (n + 1)\\cdot\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor &amp; (a \\ge n \\lor b \\ge n)\\\\nm - f(c, c - b - 1, a, m - 1) &amp; \\text{otherwise}\\end{cases}$$ g一切都变得套路了起来。 我们 定义 $g(a, b, c, n) = \\sum_{i = 0}^{n}\\left(i\\cdot\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right)$。 当 $a \\ge c$ 或 $b \\ge c$ 时： $$\\begin{aligned} g(a, b, c, n) &amp; = \\sum_{i = 0}^{n}\\left(i\\cdot\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right) \\\\ &amp; = \\sum_{i = 0}^{n}\\left(i\\cdot\\left\\lfloor\\dfrac{\\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot c + a \\bmod c\\right) \\cdot i + \\left(\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\cdot c + b \\bmod c\\right)}{c}\\right\\rfloor\\right) \\\\ &amp; = \\sum_{i = 0}^{n}\\left(i\\cdot \\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot i + \\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\right) + i\\cdot\\left\\lfloor\\dfrac{\\left(a \\bmod c\\right) \\cdot i + \\left(b \\bmod c\\right)}{c}\\right\\rfloor\\right) \\\\ &amp; = \\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot\\sum_{i = 0}^{n}i^2 + \\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\cdot\\sum_{i = 0}^{n}i + \\sum_{i = 0}^{n}\\left(i\\cdot\\left\\lfloor\\dfrac{\\left(a \\bmod c\\right) \\cdot i + \\left(b \\bmod c\\right)}{c}\\right\\rfloor\\right) \\\\ &amp; = \\dfrac{n(n + 1)(2n + 1)}{6}\\cdot\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor + (n + 1)\\cdot\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor + g(a \\bmod c, b \\bmod c, c, n)\\end{aligned}$$ 当 $a &lt; c$ 且 $b &lt; c$ 时： $$\\begin{aligned} g(a, b, c, n) &amp; = \\sum_{i = 0}^{n}\\left(i\\cdot\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right) \\\\ &amp; = \\sum_{i = 0}^{n}i\\cdot\\left(\\sum_{j = 0}^{\\left\\lfloor\\tfrac{ai + b}{c}\\right\\rfloor - 1}1\\right) \\\\ &amp; = \\sum_{i = 0}^{n}i\\cdot\\left(\\sum_{j = 0}^{m}\\left[j &lt; \\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right]\\right) \\\\ &amp; = \\sum_{j = 0}^{m - 1}i\\cdot\\sum_{i = 0}^{n}\\left[i &gt; t\\right] \\\\ &amp; = \\sum_{j = 0}^{m - 1}\\sum_{i = 0}^{n}\\left[i &gt; t\\right]\\cdot i \\\\ &amp; = \\sum_{j = 0}^{m - 1}\\cdot\\sum_{i = t + 1}^{n}1 \\\\ &amp; = \\sum_{j = 0}^{m - 1}\\dfrac{(t + n + 1)(n - t)}{2} \\\\ &amp; = \\dfrac{1}{2}\\sum_{j = 0}^{m - 1}\\bigg(n(n + 1) - t^2 - t\\bigg) \\\\ &amp; = \\dfrac{1}{2}mn(n + 1) - \\dfrac{1}{2}\\sum_{j = 0}^{m - 1}t^2 - \\dfrac{1}{2}\\sum_{j = 0}^{m - 1}t \\\\ &amp; = \\dfrac{1}{2}mn(n + 1) - \\dfrac{1}{2}\\sum_{j = 0}^{m - 1}\\left(\\left\\lfloor\\dfrac{cj + (c - b - 1)}{a}\\right\\rfloor\\right)^2 - \\dfrac{1}{2}\\sum_{j = 0}^{m - 1}\\left(\\left\\lfloor\\dfrac{cj + (c - b - 1)}{a}\\right\\rfloor\\right) \\\\ &amp; = \\dfrac{1}{2}mn(n + 1) - \\dfrac{1}{2}h(c, c - b - 1, a, m - 1) - \\dfrac{1}{2}g(c, c - b - 1, a, m - 1)\\end{aligned}$$ 综上所述，我们得到了 $g$ 的递推式： $$g(a, b, c, n) =\\begin{cases}\\dfrac{n(n + 1)(2n + 1)}{6}\\cdot\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor +(n + 1)\\cdot\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor + g(a \\bmod c, b \\bmod c, c, n) &amp; (a \\ge c \\lor b \\ge c) \\\\\\dfrac{1}{2}mn(n + 1) - \\dfrac{1}{2}h(c, c - b - 1, a, m - 1) - \\dfrac{1}{2}g(c, c - b - 1, a, m - 1) &amp; \\text{otherwise}\\end{cases}$$ h我们 定义 $h(a, b, c, n) = \\sum_{i = 0}^{n}\\left(\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right)^2$。 当 $a \\ge c$ 或 $b \\ge c$ 时： $$\\begin{aligned}h(a, b, c, n) &amp; = \\sum_{i = 0}^{n}\\left(\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right)^2 \\\\&amp; = \\sum_{i = 0}^{n}\\left(\\left\\lfloor\\dfrac{\\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot c + a \\bmod c\\right) \\cdot i + \\left(\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\cdot c + b \\bmod c\\right)}{c}\\right\\rfloor\\right)^2 \\\\&amp; = \\sum_{i = 0}^{n}\\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot i + \\left\\lfloor\\dfrac{b}{c}\\right\\rfloor + \\left\\lfloor\\dfrac{\\left(a \\bmod c\\right) \\cdot i + \\left(b \\bmod c\\right)}{c}\\right\\rfloor\\right)^2 \\\\&amp; = \\sum_{i = 0}^{n}\\Bigg(\\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot i\\right)^2 + \\left(\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\right)^2 + \\left(\\left\\lfloor\\dfrac{\\left(a \\bmod c\\right) \\cdot i + \\left(b \\bmod c\\right)}{c}\\right\\rfloor\\right)^2 \\\\&amp; + 2 \\cdot \\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot i\\right)\\cdot\\left(\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\right) + 2 \\cdot \\left(\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\right)\\cdot\\left\\lfloor\\dfrac{\\left(a \\bmod c\\right) \\cdot i + \\left(b \\bmod c\\right)}{c}\\right\\rfloor \\\\&amp; + 2\\cdot\\left\\lfloor\\dfrac{\\left(a \\bmod c\\right) \\cdot i + \\left(b \\bmod c\\right)}{c}\\right\\rfloor\\cdot\\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot i\\right)\\Bigg) \\\\&amp; = \\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\right)^2\\sum_{i = 0}^{n}i^2 + 2\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\sum_{i = 0}^{n}i + \\left(\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\right)^2\\sum_{i = 0}^{n}1 \\\\&amp; + \\sum_{i = 0}^{n}\\left(\\left\\lfloor\\dfrac{\\left(a \\bmod c\\right) \\cdot i + \\left(b \\bmod c\\right)}{c}\\right\\rfloor\\right)^2 + 2\\cdot\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\sum_{i = 0}^{n}\\left(\\left\\lfloor\\dfrac{\\left(a \\bmod c\\right) \\cdot i + \\left(b \\bmod c\\right)}{c}\\right\\rfloor\\right) \\\\&amp; + 2\\cdot\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\sum_{i = 0}^{n}\\left(i\\cdot\\left\\lfloor\\dfrac{\\left(a \\bmod c\\right) \\cdot i + \\left(b \\bmod c\\right)}{c}\\right\\rfloor\\right) \\\\&amp; = \\dfrac{n(n + 1)(2n + 1)}{6}\\cdot\\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\right)^2 + n(n + 1)\\cdot\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor + (n + 1)\\cdot\\left(\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\right)^2 \\\\&amp; + 2\\cdot\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor f(a \\bmod c, b \\bmod c, c, n) + 2\\cdot\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor g(a \\bmod c, b \\bmod c, c, n) + h(a \\bmod c, b \\bmod c, c, n)\\end{aligned}$$ 当 $a &lt; c$ 且 $b &lt; c$ 时： $$\\begin{aligned}h(a, b, c, n) &amp; = \\sum_{i = 0}^{n}\\left(\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right)^2 \\\\&amp; = \\sum_{i = 0}^{n}\\left(2\\cdot\\dfrac{\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\cdot\\left(\\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor + 1\\right)}{2} - \\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right) \\\\&amp; = -f(a, b, c, n) + 2\\sum_{i = 0}^{n}\\sum_{j = 0}^{\\left\\lfloor\\tfrac{ai + b}{c}\\right\\rfloor}j \\\\&amp; = -f(a, b, c, n) + 2\\sum_{i = 0}^{n}\\sum_{j = 1}^{\\left\\lfloor\\tfrac{ai + b}{c}\\right\\rfloor}j \\\\&amp; = -f(a, b, c, n) + 2\\sum_{i = 0}^{n}\\sum_{j = 0}^{\\left\\lfloor\\tfrac{ai + b}{c}\\right\\rfloor - 1}(j + 1) \\\\&amp; = -f(a, b, c, n) + 2\\sum_{j = 0}^{m - 1}(j + 1)\\sum_{i = 0}^{n}\\left[j &lt; \\left\\lfloor\\dfrac{ai + b}{c}\\right\\rfloor\\right] \\\\&amp; = -f(a, b, c, n) + 2\\sum_{j = 0}^{m - 1}(j + 1)\\sum_{i = 0}^{n}\\left[i &gt; t\\right] \\\\&amp; = -f(a, b, c, n) + 2\\sum_{j = 0}^{m - 1}(j + 1)(n - t) \\\\&amp; = -f(a, b, c, n) + 2n\\sum_{j = 0}^{m - 1}(j + 1) - 2\\sum_{j = 0}^{m - 1}(j + 1)t \\\\&amp; = -f(a, b, c, n) + nm(m + 1) - 2\\sum_{j = 0}^{m - 1}jt - \\sum_{j = 0}^{m - 1}t \\\\&amp; = -f(a, b, c, n) + nm(m + 1) - 2\\sum_{j = 0}^{m - 1}\\left(j\\cdot\\left\\lfloor\\dfrac{cj + c - b - 1}{a}\\right\\rfloor\\right) - \\sum_{j = 0}^{m - 1}\\left\\lfloor\\dfrac{cj + c - b - 1}{a}\\right\\rfloor \\\\&amp; = -f(a, b, c, n) + nm(m + 1) - 2g(c, c - b - 1, a, m - 1) - 2f(c, c - b - 1, a, m - 1);\\end{aligned}$$ 综上所述，我们得到了 $h$ 的递推式： $$h(a, b, c, n) =\\begin{cases}\\dfrac{n(n + 1)(2n + 1)}{6}\\cdot\\left(\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\right)^2 &amp; + n(n + 1)\\cdot\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor\\cdot\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor + (n + 1)\\cdot\\left(\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\right)^2 \\\\&amp; + 2\\cdot\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor f(a \\bmod c, b \\bmod c, c, n) \\\\&amp; + 2\\cdot\\left\\lfloor\\dfrac{a}{c}\\right\\rfloor g(a \\bmod c, b \\bmod c, c, n) \\\\ &amp; + h(a \\bmod c, b \\bmod c, c, n) &amp; (a \\ge c \\lor b \\ge c) \\\\f(a, b, c, n) + nm(m + 1) &amp; - 2g(c, c - b - 1, a, m - 1) \\\\ &amp; - 2f(c, c - b - 1, a, m - 1) &amp; \\text{otherwise}\\end{cases}$$ 时间复杂度证明不会。 代码实现这里给出 【模板】类欧几里得算法 的代码实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;#define LL long long#define LOCALnamespace io &#123; template &lt;typename T&gt; inline void read(T &amp; _x) &#123; int f = 0, ch; _x = 0; while(!isdigit(ch = getchar())) f |= ch == '-'; while(isdigit(ch)) _x = _x * 10 + ch - '0', ch = getchar(); if(f) _x = -_x; &#125; template &lt;typename T, typename ... Args&gt; inline void read(T &amp;_f, Args&amp; ... args) &#123; read(_f), read(args ...); &#125; inline void _deal(char ch) &#123; putchar(ch); &#125; template &lt;typename T&gt; inline void _deal(T _x) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; if (_x &gt; 9) _deal(_x / 10); putchar(_x % 10 + '0'); &#125; inline void write() &#123;&#125; template &lt;typename T, typename ... Args&gt; inline void write(T _f, Args ... args) &#123; _deal(_f), write(args...); &#125;&#125;const int mod = 998244353;const int inv2 = 499122177;const int inv6 = 166374059;LL t, A, B, C, N;struct QUERY &#123; LL f, g, h;&#125;;QUERY solve(LL a, LL b, LL c, LL n) &#123; QUERY res, tmp; if(!a) &#123; res.f = (b / c) * (n + 1) % mod; res.g = (b / c) * inv2 % mod * n % mod * (n + 1) % mod; res.h = (b / c) * (b / c) % mod * (n + 1) % mod; return res; &#125; else if(a &gt;= c || b &gt;= c) &#123; tmp = solve(a % c, b % c, c, n); res.f = (tmp.f + (a / c) * inv2 % mod * n % mod * (n + 1) % mod + (b / c) * (n + 1) % mod) % mod; res.g = (tmp.g + (a / c) * inv6 % mod * n % mod * (n + 1) % mod * (2 * n + 1) % mod + (b / c) * inv2 % mod * n % mod * (n + 1) % mod) % mod; res.h = (tmp.h + (b / c) * 2 % mod * tmp.f % mod + (a / c) * 2 % mod * tmp.g % mod + (a / c) * (a / c) % mod * inv6 % mod * n % mod * (n + 1) % mod * (2 * n + 1) % mod + (b / c) * (b / c) % mod * (n + 1) % mod + (a / c) * (b / c) % mod * n % mod * (n + 1) % mod) % mod; return res; &#125; else &#123; LL m = (a * n + b) / c; tmp = solve(c, c - b - 1, a, m - 1); res.f = ((m * n % mod - tmp.f) % mod + mod) % mod; res.g = inv2 * (((m * n % mod * (n + 1) % mod - tmp.f - tmp.h) % mod + mod) % mod) % mod; res.h = ((n * m % mod * (m + 1) % mod - res.f - 2 * tmp.g % mod - 2 * tmp.f % mod) % mod + mod) % mod; return res; &#125;&#125;int main() &#123;#ifdef LOCAL freopen(\"sim.in\", \"r\", stdin); freopen(\"sim.out\", \"w\", stdout);#endif io::read(t); while(t--) &#123; io::read(N, A, B, C); QUERY cur = solve(A, B, C, N); io::write(cur.f, ' ', cur.h, ' ', cur.g, '\\n'); &#125; return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数论","slug":"学习笔记/数论","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://leverimmy.top/tags/%E9%80%92%E5%BD%92/"},{"name":"类欧几里德算法","slug":"类欧几里德算法","permalink":"https://leverimmy.top/tags/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95/"}]},{"title":"【学习笔记】Karatsuba 乘法学习笔记","slug":"【学习笔记】Karatsuba-乘法学习笔记","date":"2020-05-04T07:40:30.000Z","updated":"2020-07-03T08:14:36.078Z","comments":true,"path":"2020/05/04/【学习笔记】Karatsuba-乘法学习笔记/","link":"","permalink":"https://leverimmy.top/2020/05/04/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Karatsuba-%E4%B9%98%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"上个学期在联赛前听 EternalAlexander 提到了一下这个玄学的算法，现在就学习一下吧。","text":"上个学期在联赛前听 EternalAlexander 提到了一下这个玄学的算法，现在就学习一下吧。 简介「Karatsuba 乘法」是 1960 年由 Anatolii Alexeevitch Karatsuba 提出的可用于大整数乘法的算法。 理论推导不妨设我们要相乘的两个数字分别为 $a$ 和 $b$，其乘积，也就是我们要求的数，为 $c$。 设 $a = x_1\\cdot10^m + x_0, b = y_1\\cdot10^m + y_0$，其中 $0 &lt; x_1, x_0, y_1, y_0 &lt; 10^m$，则 $\\begin{aligned}c = ab &amp; = (x_1\\cdot10^m + x_0) \\cdot (y_1\\cdot10^m + y_0) \\\\ &amp; = (x_1\\cdot y_1)10^{2m} + (x_1\\cdot y_0 + x_0\\cdot y_1)10^m + x_0\\cdot y_0\\end{aligned}$ 记 $z_2 = x_1\\cdot y_1, z_1 = x_1\\cdot y_0 + x_0\\cdot y_1, z_0 = x_0\\cdot y_0$。 注意到，$z_1 = (x_1 + x_0)(y_1 + y_0) - z_2 - z_0$。 于是我们可以分步计算 $(x_1 + x_0)(y_1 + y_0), z_2, z_0$ 即可。 时间复杂度我们实质上是把一个 $n \\times n$ 的乘法化简为了三个长度更小的乘法。 当 $m = \\left\\lfloor\\dfrac{n}{2}\\right\\rfloor$ 时，有递推式 $T(n) = 3T(\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor) + O(n)$。 不难由主定理得知 $T(n) = \\Theta(n^{\\log_{2}3}) \\approx \\Theta(n^{1.585})$ 代码实现这个是 MUL - Fast Multiplication 的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;#define LL long long#define LOCALnamespace io &#123; template &lt;typename T&gt; inline void read(T &amp; _x) &#123; int f = 0, ch; _x = 0; while(!isdigit(ch = getchar())) f |= ch == '-'; while(isdigit(ch)) _x = _x * 10 + ch - '0', ch = getchar(); if(f) _x = -_x; &#125; template &lt;typename T, typename ... Args&gt; inline void read(T &amp;_f, Args&amp; ... args) &#123; read(_f), read(args ...); &#125; inline void _deal(char ch) &#123; putchar(ch); &#125; template &lt;typename T&gt; inline void _deal(T _x) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; if (_x &gt; 9) _deal(_x / 10); putchar(_x % 10 + '0'); &#125; inline void write() &#123;&#125; template &lt;typename T, typename ... Args&gt; inline void write(T _f, Args ... args) &#123; _deal(_f), write(args...); &#125;&#125;const int N = 1e4 + 5;int t, n, m;int a[N], b[N], c[N &lt;&lt; 1];char A[N], B[N];int *Kmul(int len, int ra[], int rb[]) &#123; if(len &lt;= 32) &#123; int *r = new int[len * 2 + 1](); for(int i = 0; i &lt;= len; ++i) for(int j = 0; j &lt;= len; ++j) r[i + j] += ra[i] * rb[j]; return r; &#125; int hf = len / 2 + 1; int *r = new int[hf * 4 + 1](); int *z0, *z1, *z2; z0 = Kmul(hf - 1, ra, rb); z2 = Kmul(len - hf, ra + hf, rb + hf); for(int i = 0; i + hf &lt;= len; ++i) ra[i] += ra[i + hf]; for(int i = 0; i + hf &lt;= len; ++i) rb[i] += rb[i + hf]; z1 = Kmul(hf - 1, ra, rb); for(int i = 0; i + hf &lt;= len; ++i) ra[i] -= ra[i + hf]; for(int i = 0; i + hf &lt;= len; ++i) rb[i] -= rb[i + hf]; for(int i = 0; i &lt;= (hf - 1) * 2; ++i) z1[i] -= z0[i]; for(int i = 0; i &lt;= (len - hf) * 2; ++i) z1[i] -= z2[i]; for(int i = 0; i &lt;= (hf - 1) * 2; ++i) r[i] += z0[i]; for(int i = 0; i &lt;= (hf - 1) * 2; ++i) r[i + hf] += z1[i]; for(int i = 0; i &lt;= (len - hf) * 2; ++i) r[i + hf * 2] += z2[i]; delete[] z0; delete[] z1; delete[] z2; return r;&#125;void Karatsuba(int ra[], int rb[], int rc[]) &#123; int *r = Kmul(n - 1, ra, rb); memcpy(rc, r, sizeof(int) * m); for(int i = 0; i &lt; m - 1; ++i) &#123; if(rc[i] &gt;= 10) &#123; rc[i + 1] += rc[i] / 10; rc[i] %= 10; &#125; &#125; delete[] r;&#125;int main() &#123;#ifdef LOCAL freopen(\"mul.in\", \"r\", stdin); freopen(\"mul.out\", \"w\", stdout);#endif io::read(t); while(t--) &#123; int len1, len2; scanf(\"%s %s\", A + 1, B + 1); len1 = strlen(A + 1), len2 = strlen(B + 1); n = std::max(len1, len2); for(int i = len1, j = len2, k = 0; k &lt; n; --i, --j, ++k) &#123; if(i &gt;= 1) a[k] = A[i] - '0'; else a[k] = 0; if(j &gt;= 1) b[k] = B[j] - '0'; else b[k] = 0; &#125; /*for(int i = 1; i &lt;= n; ++i) printf(\"%d\", a[i]); putchar('\\n'); for(int i = 1; i &lt;= n; ++i) printf(\"%d\", b[i]); putchar('\\n');*/ m = len1 + len2 - 1; Karatsuba(a, b, c); while(!c[m - 1] &amp;&amp; m &gt; 1) --m; for(int i = m - 1; i &gt;= 0; --i) io::write(c[i]); io::write('\\n'); &#125; return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"杂项","slug":"学习笔记/杂项","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"https://leverimmy.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"分治","slug":"分治","permalink":"https://leverimmy.top/tags/%E5%88%86%E6%B2%BB/"},{"name":"技巧","slug":"技巧","permalink":"https://leverimmy.top/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"【学习笔记】经典动态规划模型学习笔记","slug":"【学习笔记】经典动态规划模型学习笔记","date":"2020-04-27T03:35:44.000Z","updated":"2020-07-03T08:16:12.208Z","comments":true,"path":"2020/04/27/【学习笔记】经典动态规划模型学习笔记/","link":"","permalink":"https://leverimmy.top/2020/04/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"「用集合的角度来理解dp。」 $\\gets$ 这个东西好像不是很好用。 大概这篇博文就只能熟悉一下各大dp模型吧？","text":"「用集合的角度来理解dp。」 $\\gets$ 这个东西好像不是很好用。 大概这篇博文就只能熟悉一下各大dp模型吧？ 区间dp概述区间dp是dp的一种，一般处理在一个序列上的关于区间的一些问题。 因为 $[l, r]$ 这个区间，可以用很多个 $[l, k] \\bigcap (k, r]$ 重复地 覆盖， 也就是通过枚举断点 $k$，来实现区间 $[l, r] \\gets [l, k] + (k, r]$ 信息的转移。 即 $f(l, r) = \\operatorname{op}\\{f(l, k) + f(k + 1, r)\\} \\quad k \\in [l, r)$。 需要注意的是 $k$ 的范围也不一定是 $[l, r)$，也有许多题是 $k \\in (l, r)$ 的， 这个时候我们就需要处理出 $len = 2$ 的，然后 for 循环从 $len = 3$ 开始。 例题 「NOI1995」石子合并 拆环成链，令 $a[n + 1\\ldots 2n] \\gets a[1 \\ldots n]$，这样就把一个环形的问题转化到了序列上。 设 $f(l, r)$ 表示第 $l$ 堆石子一直合并到第 $r$ 堆石子，能获得的最大值； 设 $g(l, r)$ 表示第 $l$ 堆石子一直合并到第 $r$ 堆石子，能获得的最小值。 因为 $[l, r]$ 可以被分成 $[l, k]$ 和 $(k, r]$，所以我们可以这么转移： $$\\begin{aligned} f(l, r) &amp; = \\max\\{sum_r - sum_{l - 1} + f(l, k) + f(k + 1, r)\\} \\quad k \\in [l, r) \\\\ g(l, r) &amp; = \\max\\{sum_r - sum_{l - 1} + g(l, k) + g(k + 1, r)\\} \\quad k \\in [l, r)\\end{aligned}$$ 「一本通 5.1 例 3」凸多边形的划分 我们将这个凸多边形的每个顶点顺时针排成一行，环上的顶点其实和序列没有区别。 设 $f(l, r)$ 表示第 $l$ 个顶点到第 $r$ 个顶点所组成的凸多边形划分后，能得到的最小值。 因为 $S(l, r)$ 可以被分成 $(l, k)$ 和 $(k, r)$，再加上 $a_l, a_r, a_k$ 的贡献，所以我们可以这么转移： $$f(l, r) = \\min\\{f(l, k) + f(k, r) + a_l\\cdot a_k\\cdot a_r\\} \\quad k \\in (l, r)$$ 「NOIP2007」矩阵取数游戏 注意到每一行的贡献其实是互不干扰的，所以我们分别对每一行进行 dp。 设 $f(l, r)$ 表示这一行取了 $m - (r - l + 1)$ 步后，还剩 $[l, r]$ 能得到的最大值。 因为 $S(l, r)$ 可以是 $S(l - 1, r) - a_{l - 1}$ 得来的，也可以是 $S(l, r + 1) - a_{r + 1}$ 得来的，所以我们可以这么转移： $$f(l, r) = \\max \\begin{cases} f(l - 1, r) + a_{l - 1} \\cdot 2^{m - (r - l + 1)} \\\\ f(l, r + 1) + a_{r + 1} \\cdot 2^{m - (r - l + 1)} \\end{cases}$$ 「CF Edu #83」E. Array Shrinking 这题比较综合，要先用区间dp预处理，然后再线性递推。 设 $f(l, r)$ 表示 $[l, r]$ 能缩合得到的数字（如果无法缩合，则 $f(l, r) = 0$） 设 $g(i)$ 表示 $[1, i]$ 可以被分成的段数的最小值。 如果 $[l, r]$ 能从 $[l, k]$ 和 $(k, r]$ 组成，那么 $f(l, k)$ 是应该等于 $f(k + 1, r)$ 的，这样才能「缩合」。所以这么转移 $f$： $$f(l, r) = \\max\\{f(l, k) + 1\\} \\quad (k \\in [l, r) \\bigwedge f(l, k) = f(k + 1, r) &gt; 0)$$ 因为 $[1, i]$ 能被分成 $[1, j]$ 和 $(j, i]$ 两段，我们只用考虑 $(j, i]$ 能否缩合得到。所以我们可以这么转移： $$g(i) = \\min\\{g(j) + 1\\} \\quad (j \\in [1, i) \\bigwedge f(j + 1, i) \\neq 0)$$ 树型dp概述树型dp是dp的一种，一般处理子树中最优解的一些问题。当然，也有「换根dp」之类的处理 整棵树 上最优解的一些问题。 例题 「一本通 5.2 例 4」战略游戏 树型dp入门题。 设 $f(u, 0)$ 表示 $u$ 上不放士兵，使得所有以 $u$ 为根的子树中的 边 被「瞭望」到，所需放置的士兵最少个数。 设 $f(u, 1)$ 表示 $u$ 上放士兵，使得所有以 $u$ 为根的子树中的 边 被「瞭望」到，所需放置的士兵最少个数。 若 $u$ 上不放置士兵，那么所有的 $v \\in \\text{son}(u)$ 上都得放士兵，才能使所有的边 $(u, v) \\quad (v \\in \\text{son}(u))$ 被瞭望到； 若 $u$ 上放置了士兵，那么所有的 $v \\in \\text{son}(u)$ 上需不需要放置士兵是随意的。所以我们可以这么转移： $$\\begin{aligned} f(u, 0) &amp; = \\sum_{v \\in \\text{son}(u)} f(v, 1) \\\\ f(u, 1) &amp; = \\sum_{v \\in \\text{son}(u)} \\min f(v, 0), f(v, 1)\\end{aligned}$$ 「一本通 5.2 练习 2」旅游规划 一个比较基础的换根dp。 首先我们钦定一个根，对这棵有根树进行dfs；再换根，算出换根后的贡献。 设 $f(u, 0)$ 表示以 $u$ 为根的子树中，最远的点的距离。 设 $f(u, 1)$ 表示以 $u$ 为根的子树中，次远的点的距离。 设 $g(u)$ 表示以 $u$ 为根的子树中，最远的点是在 哪一个孩子的子树中。 设 $h(u)$ 表示不经过 $u$ 的子树，最远的点的距离。 不难发现，原来的无根树的直径，为 $\\max\\{f(i, 0), \\max\\{f(i, 1), h(i)\\}\\}$，即 从自己的某个孩子的子树中有一条路径一直延伸到另一个孩子，或者是这棵树的「另一半部分」。 最后我们输出的，就是所有 $f(i, 0), \\max\\{f(i, 1), h(i)\\}$ 等于直径长度的 $i$。 在第一次dfs中，我们是 从孩子往双亲 转移的，方程是显然的： $$\\begin{aligned} f(u, 0) &amp; = \\max_{v \\in \\text{son}(u)}\\{f(v, 0) + 1\\} \\\\ f(u, 1) &amp; = \\text{second}\\max_{v \\in \\text{son}(u)}\\{f(v, 0) + 1\\}\\end{aligned}$$ 转移时顺便更新 $g$ 即可。接下来我们要重点考虑的是 第二次dfs 会带来什么样的影响，也就是应该如何计算 $h$ 值。 第二次dfs是自顶向下的，也就是 从双亲往孩子 转移的。 从 $u$ 不经过子树的最长距离，肯定是 $u$ 的父亲 $x$ 能走一条特别远的路径出来。 那么这条路径有两种可能：要么是 $x$ 往 $x$ 的孩子（但不是 $u$）的方向走，要么是 $x$ 往 $x$ 的父亲 $y$ 的方向走。 如果 $u$ 是 $g$ 中记录的最大孩子，那么第一种可能，就只能走次大孩子，即 $f(x, 1)$；第二种可能就是 $h(x)$； 如果 $u$ 不是 $g$ 中记录的最大孩子，那么第一种可能，就能走最大孩子，即 $f(x, 0)$；第二种可能还是 $h(x)$； 那么我们可以推导出转移方程： $$h(v) = \\begin{cases}\\max\\{h(u), f(u, 1)\\} &amp; v = g(u), u = \\text{father}(v) \\\\ \\max\\{h(u), f(u, 0)\\} &amp; v \\neq g(u), u = \\text{father}(v)\\end{cases}$$ 状压dp概述假设有一行格子，要你黑白染色，你会怎么考虑表示这一行的状态呢？ 假设 $1$ 表示黑色，$0$ 表示白色，那这一行是不是就等价于一个二进制数呢？ 状压dp 就是通过用二进制数来表示状态的一种dp类型。 通常除了二进制，还有三进制（不能使用位运算，但是能暴力拆位）。 例题 「SCOI2005」互不侵犯 状压dp 入门题。 我们可以用一个 $n$ 位二进制数 $st$ 来表示这一行的状态，第 $i$ 位为 $1$ 表示这个格子上有王，为 $0$ 则表示这个格子是空的。 显然如果一个状态 $st$ 是合法的，当且仅当 $st \\&amp; (st / 2) = 0 \\bigwedge st \\&amp; (st \\cdot 2) = 0$。 然后还要枚举上一行的状态，判断上一行的状态会不会和这一行的状态冲突。 状态转移方程便是： $$ f(i, st, cnt) = \\sum_{pr}f(i - 1, pr, cnt - \\operatorname{popcount}(st))$$ 其中 $st, pr$ 均为合法状态，且 $st$ 与 $pr$ 不冲突，后文同。 $\\operatorname{popcount}(x)$ 表示 $x$ 的二进制表示中 $1$ 的个数。 答案即为 $\\sum_{st}f(n, st, k)$。 「一本通 5.4 练习 1」涂抹果酱 稍微有点复杂的三进制状态压缩。 首先，一个状态是否是合法的，我们可以暴力求出这个状态的三进制表示。 然后逐个判断相邻的两个位是否不同即可。 其次，相邻两行的状态是否不会冲突，我们可以暴力同时取出这两个状态在三进制表示下的每一位，逐个比较是否相同即可。 然后是转移，因为已经固定了第 $k$ 行，我们可以看做是把这个棋盘分割成了 互不干扰 的 $[1, k)$ 和 $(k, n]$ 两部分。 分别求出来方案数然后 相乘 即可得到最终答案。 剩下的部分与 「SCOI2005」互不侵犯 类似，就不再赘述。 状态转移方程如下： $$ f(i, st) = \\sum_{pr}f(i - 1, pr)$$ 答案即为 $$ ans_{k}\\cdot ans_{n - k + 1} = \\left(\\sum_{st}f(k, st)\\right)\\cdot\\left(\\sum_{st}f(n - k + 1, st)\\right)$$ 「APIO2007」动物园 比较有技巧性的一道状压dp题。 我们可以发现，一个人只能看见长度为 $5$ 的「窗口」，所以我们可以利用这一点来进行状态压缩。我们把一个人能看到的动物压缩成一个二进制数，第 $i$ 位为 $1$ 表示能看见 $i$ 这个动物，否则就看不见这个动物。 首先我们预处理出 $g(i, st)$，表示从第 $i$ 个动物开始，往后的 $5$ 个动物被移走，即移走状态为 $st$ 时的满意人数。 其次我们设 $f(i, st)$ 表示 $[1, i]$，往后的 $5$ 个动物被移走，即移走状态为 $st$ 时的最大满意人数。 可以推出状态转移方程： $$ f(i, st) = \\max\\{f(i - 1, st \\cdot 2), f(i - 1, st \\cdot 2 + 1) + g(i, st)\\}$$ 我们从第 $1$ 个开始枚举，然后要满足第 $n + 1$ 个的状态和第 $1$ 个状态相同即可。 数位dp","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"动态规划","slug":"学习笔记/动态规划","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://leverimmy.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"【洛谷】P3356 火星探险问题","slug":"【洛谷】P3356-火星探险问题","date":"2020-04-19T08:31:44.000Z","updated":"2020-07-03T08:06:59.449Z","comments":true,"path":"2020/04/19/【洛谷】P3356-火星探险问题/","link":"","permalink":"https://leverimmy.top/2020/04/19/%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P3356-%E7%81%AB%E6%98%9F%E6%8E%A2%E9%99%A9%E9%97%AE%E9%A2%98/","excerpt":"题意简述：给定一个 $p \\times q$ 的矩阵和 $n$ 个位于 $(1, 1)$ 的机器人，每个格子里为下列三种状态之一： 「无障碍」，机器人可以通过； 「有障碍」，机器人不能通过； 「有矿物」，机器人通过后会得到 $1$ 个单位的石头，只能被获得一次。 每个机器人只能 $(x, y) \\to (x + 1, 1)$ 或 $(x, y) \\to (x, y + 1)$。 求使得所有机器人到达 $(p, q)$ 时，石头总量最多的一种方案。 $1 \\le p, q, n \\le 35$。 题目链接","text":"题意简述：给定一个 $p \\times q$ 的矩阵和 $n$ 个位于 $(1, 1)$ 的机器人，每个格子里为下列三种状态之一： 「无障碍」，机器人可以通过； 「有障碍」，机器人不能通过； 「有矿物」，机器人通过后会得到 $1$ 个单位的石头，只能被获得一次。 每个机器人只能 $(x, y) \\to (x + 1, 1)$ 或 $(x, y) \\to (x, y + 1)$。 求使得所有机器人到达 $(p, q)$ 时，石头总量最多的一种方案。 $1 \\le p, q, n \\le 35$。 题目链接 解题思路：这类有限制通过的问题，我们考虑拆点来转化。 将每个点分为 $(x, y, 1)$ 和 $(x, y, 2)$。 若 $(x, y)$ 为「无障碍」，则在 $(x, y, 1)$ 与 $(x, y, 2)$ 间连一条流量为 $\\inf$，费用为 $0$ 的边。 若 $(x, y)$ 为「有障碍」，则不连边。 若 $(x, y)$ 为「有矿物」，则在 $(x, y, 1)$ 与 $(x, y, 2)$ 间连一条流量为 $\\inf$，费用为 $0$ 的边，表示不取这块石头；再连一条流量为 $1$，费用为 $-1$ 的边，表示取走这块石头。 最后求最小费用最大流即可，石头总量即为费用的相反数。 读入和 zkw 我就不贴了。 参考代码： Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#define LL long long#define LOCALconst int inf = 0x3f3f3f3f;const int N = 1e6 + 5;const int M = 1e6 + 5;const int S = 50 + 5;int n, m, p, q, idx, a[S][S], id[S][S];int cnt, first[N], s, t, min_cost, max_flow;int len, ans[N], tmp[N];int id1(int x, int y) &#123; return id[x][y];&#125;int id2(int x, int y) &#123; return id[x][y] + idx;&#125;bool valid(int x, int y) &#123; if(x &lt; 1 || x &gt; q || y &lt; 1 || y &gt; p) return 0; return a[x][y] != 1;&#125;void dfs(int x, int y) &#123; int u = id2(x, y); for(int i = first[u]; ~i; i = e[i]._next) &#123; int v = e[i].to; if(tmp[i] &gt;= e[i ^ 1].wt) continue; if(v == id1(x + 1, y)) &#123; ++tmp[i], ans[++len] = 0; dfs(x + 1, y); return; &#125; if(v == id1(x, y + 1)) &#123; ++tmp[i], ans[++len] = 1; dfs(x, y + 1); return; &#125; &#125;&#125;int main() &#123;#ifdef LOCAL freopen(\"mars.in\", \"r\", stdin); freopen(\"mars.out\", \"w\", stdout);#endif io::read(n, p, q); memset(first, -1, sizeof(first)); for(int i = 1; i &lt;= q; ++i) for(int j = 1; j &lt;= p; ++j) io::read(a[i][j]), id[i][j] = ++idx; s = 0, t = idx * 2 + 1; for(int i = 1; i &lt;= q; ++i) &#123; for(int j = 1; j &lt;= p; ++j) &#123; if(a[i][j] == 0) Connect(id1(i, j), id2(i, j), inf, 0); else if(a[i][j] == 2) &#123; Connect(id1(i, j), id2(i, j), inf, 0); Connect(id1(i, j), id2(i, j), 1, -1); &#125; &#125; &#125; Connect(s, id1(1, 1), n, 0); Connect(id2(q, p), t, inf, 0); for(int i = 1; i &lt;= q; ++i) for(int j = 1; j &lt;= p; ++j) &#123; if(valid(i, j) &amp;&amp; valid(i + 1, j)) Connect(id2(i, j), id1(i + 1, j), inf, 0); if(valid(i, j) &amp;&amp; valid(i, j + 1)) Connect(id2(i, j), id1(i, j + 1), inf, 0); &#125; zkw.solve(s, t); for(int i = 1; i &lt;= max_flow; ++i) &#123; len = 0, dfs(1, 1); for(int j = 1; j &lt;= len; ++j) io::write(i, ' ', ans[j], '\\n'); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"https://leverimmy.top/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"网络流 24 题","slug":"网络流-24-题","permalink":"https://leverimmy.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-24-%E9%A2%98/"}]},{"title":"【洛谷】P4009 汽车加油行驶问题","slug":"【洛谷】P4009-汽车加油行驶问题","date":"2020-04-18T14:51:32.000Z","updated":"2020-07-03T08:29:18.182Z","comments":true,"path":"2020/04/18/【洛谷】P4009-汽车加油行驶问题/","link":"","permalink":"https://leverimmy.top/2020/04/18/%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P4009-%E6%B1%BD%E8%BD%A6%E5%8A%A0%E6%B2%B9%E8%A1%8C%E9%A9%B6%E9%97%AE%E9%A2%98/","excerpt":"题意简述：题意比较复杂，建议到 OJ 上查看。 题目链接","text":"题意简述：题意比较复杂，建议到 OJ 上查看。 题目链接 解题思路：考虑分层图建最短路。 每一个点，都可以免费到达下一层的自己，或者是 若有加油站，可以加满油，即到达第 $1$ 层的自己，边权为 $A$； 坐标（$x$ 或 $y$）减小，则边权为 $B$； 坐标（$x$ 或 $y$）增大，免费； 若无加油站，可以增设加油站，直接到达第 $1$ 层的自己，边权为 $A + C$。 最后跑一边最短路即可，记得空间要开够，不然会 RE，答案即为每一层终点的 dis 的最小值。 Dijkstra 我就不贴了。 参考代码： Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;#define LL long long#define LOCALnamespace io &#123; template &lt;typename T&gt; inline void read(T &amp; _x) &#123; int f = 0, ch; _x = 0; while(!isdigit(ch = getchar())) f |= ch == '-'; while(isdigit(ch)) _x = _x * 10 + ch - '0', ch = getchar(); if(f) _x = -_x; &#125; template &lt;typename T, typename ... Args&gt; inline void read(T &amp;_f, Args&amp; ... args) &#123; read(_f), read(args ...); &#125; inline void _deal(char ch) &#123; putchar(ch); &#125; template &lt;typename T&gt; inline void _deal(T _x) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; if (_x &gt; 9) _deal(_x / 10); putchar(_x % 10 + '0'); &#125; inline void write() &#123;&#125; template &lt;typename T, typename ... Args&gt; inline void write(T _f, Args ... args) &#123; _deal(_f), write(args...); &#125;&#125;const int inf = 0x3f3f3f3f;const int N = 2e6 + 5;const int M = 2e6 + 5;const int S = 1e2 + 5;int n, k, A, B, C, cnt, s, t, ans = inf;int first[N], vis[N], dis[N], pos[N];int G(int x, int y, int lvl) &#123; return S * S * (x - 1) + S *(y - 1) + lvl;&#125;int main() &#123;#ifdef LOCAL freopen(\"car.in\", \"r\", stdin); freopen(\"car.out\", \"w\", stdout);#endif io::read(n, k, A, B, C); memset(first, -1, sizeof(first)); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; int opt; io::read(opt); for(int lv = 1; lv &lt;= k; ++lv) Add_Edge(G(i, j, lv), G(i, j, lv + 1), 0); switch (opt) &#123; case 0: for(int lv = 1; lv &lt;= k; ++lv) &#123; if(i &lt; n) Add_Edge(G(i, j, lv), G(i + 1, j, lv + 1), 0); if(j &lt; n) Add_Edge(G(i, j, lv), G(i, j + 1, lv + 1), 0); if(i &gt; 1) Add_Edge(G(i, j, lv), G(i - 1, j, lv + 1), B); if(j &gt; 1) Add_Edge(G(i, j, lv), G(i, j - 1, lv + 1), B); &#125; for(int lv = 2; lv &lt;= k + 1; ++lv) Add_Edge(G(i, j, lv), G(i, j, 1), A + C); break; case 1: for(int lv = 2; lv &lt;= k + 1; ++lv) Add_Edge(G(i, j, lv), G(i, j, 1), A); if(i &lt; n) Add_Edge(G(i, j, 1), G(i + 1, j, 2), 0); if(j &lt; n) Add_Edge(G(i, j, 1), G(i, j + 1, 2), 0); if(i &gt; 1) Add_Edge(G(i, j, 1), G(i - 1, j, 2), B); if(j &gt; 1) Add_Edge(G(i, j, 1), G(i, j - 1, 2), B); break; &#125; &#125; &#125; Dijkstra(G(1, 1, 1)); for(int lv = 1; lv &lt;= k + 1; ++lv) ans = std::min(ans, dis[G(n, n, lv)]); io::write(ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"网络流 24 题","slug":"网络流-24-题","permalink":"https://leverimmy.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-24-%E9%A2%98/"},{"name":"最短路","slug":"最短路","permalink":"https://leverimmy.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"【洛谷】P4013 数字梯形问题","slug":"【洛谷】P4013-数字梯形问题","date":"2020-04-18T09:59:51.000Z","updated":"2020-07-03T08:08:34.423Z","comments":true,"path":"2020/04/18/【洛谷】P4013-数字梯形问题/","link":"","permalink":"https://leverimmy.top/2020/04/18/%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P4013-%E6%95%B0%E5%AD%97%E6%A2%AF%E5%BD%A2%E9%97%AE%E9%A2%98/","excerpt":"题意简述：给定一个如图所示的梯形，梯形的第一行有 $m$ 个数字，共有 $n$ 行。 从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。 从梯形的顶至底的 $m$ 条路径互不相交； 从梯形的顶至底的 $m$ 条路径仅在数字结点处相交； 从梯形的顶至底的 $m$ 条路径允许在数字结点相交或边相交。 分别求在这三种约束下，能得到的数字和的最大值。 $1 \\le m, n \\le 20$。 题目链接","text":"题意简述：给定一个如图所示的梯形，梯形的第一行有 $m$ 个数字，共有 $n$ 行。 从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。 从梯形的顶至底的 $m$ 条路径互不相交； 从梯形的顶至底的 $m$ 条路径仅在数字结点处相交； 从梯形的顶至底的 $m$ 条路径允许在数字结点相交或边相交。 分别求在这三种约束下，能得到的数字和的最大值。 $1 \\le m, n \\le 20$。 题目链接 解题思路：task 1考虑拆点，每个具有 $w_{i, j}$ 的价值的点 $(i, j)$ 拆成 $u(i, j) \\overset{w_{i, j}\\quad}\\Longrightarrow u’(i, j)$。 这样就能保证每个点都只被经过一次。 task 2既然每个点可以被重复经过，而每条边都不行，那么就设置每条转移的边的流量为 $1$ 即可。 task 3直接自底向顶 dp 就好了，状态转移方程是 $f(i, j) = \\max\\{f(i + 1, j), f(i + 1, j + 1)\\} + w_{i, j}$； 答案为 $\\sum_{i = 1}^{m}f(1, i)$。 技巧这类求 最大值 的题目，通常采用把价值 取相反数 后跑最小费用最大流的方式，来解决问题。 zkw 和快读我就不贴了。 参考代码： Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;#define LL long long#define LOCALconst int inf = 0x3f3f3f3f;const int N = 1e5 + 5;const int M = 1e5 + 5;const int S = 50 + 5;int n, m, a[S][S];int s, t, min_cost, max_flow;int cnt, first[N], idx, id[S][S];struct EDGE &#123; int to, _next, wt, ct;&#125; e[M &lt;&lt; 1];void Add_Edge(int u, int v, int w, int c) &#123; e[cnt].to = v, e[cnt].wt = w, e[cnt].ct = c, e[cnt]._next = first[u]; first[u] = cnt++;&#125;void Connect(int u, int v, int w, int c) &#123; Add_Edge(u, v, w, c), Add_Edge(v, u, 0, -c);&#125;namespace task1 &#123; int id1(int x, int y) &#123; return id[x][y]; &#125; int id2(int x, int y) &#123; return id[x][y] + idx; &#125; void solve() &#123; memset(first, -1, sizeof(first)), cnt = min_cost = 0; for(int i = 1; i &lt;= n - 1; ++i) for(int j = 1; j &lt;= m + i - 1; ++j) &#123; Connect(id2(i, j), id1(i + 1, j), 1, 0); Connect(id2(i, j), id1(i + 1, j + 1), 1, 0); &#125; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m + i - 1; ++j) Connect(id1(i, j), id2(i, j), 1, -a[i][j]); for(int i = 1; i &lt;= m; ++i) Connect(s, id1(1, i), 1, 0); for(int i = 1; i &lt;= m + n - 1; ++i) Connect(id2(n, i), t, 1, 0); zkw.solve(s, t); io::write(-min_cost, '\\n'); &#125;&#125;namespace task2 &#123; int Id(int x, int y) &#123; return id[x][y]; &#125; void solve() &#123; memset(first, -1, sizeof(first)), cnt = min_cost = 0; for(int i = 1; i &lt;= n - 1; ++i) for(int j = 1; j &lt;= m + i - 1; ++j) &#123; Connect(Id(i, j), Id(i + 1, j), 1, -a[i][j]); Connect(Id(i, j), Id(i + 1, j + 1), 1, -a[i][j]); &#125; for(int i = 1; i &lt;= m; ++i) Connect(s, Id(1, i), 1, 0); for(int i = 1; i &lt;= m + n - 1; ++i) Connect(Id(n, i), t, inf, -a[n][i]); zkw.solve(s, t); io::write(-min_cost, '\\n'); &#125;&#125;namespace task3 &#123; int ans = 0, f[S][S] = &#123;0&#125;; void solve() &#123; for(int i = 1; i &lt;= m + n - 1; ++i) f[n][i] = a[n][i]; for(int i = n - 1; i &gt;= 1; --i) for(int j = 1; j &lt;= m + i - 1; ++j) f[i][j] = a[i][j] + std::max(f[i + 1][j], f[i + 1][j + 1]); for(int i = 1; i &lt;= m; ++i) ans += f[1][i]; io::write(ans, '\\n'); &#125;&#125;int main() &#123;#ifdef LOCAL freopen(\"number.in\", \"r\", stdin); freopen(\"number.out\", \"w\", stdout);#endif io::read(m, n); memset(first, -1, sizeof(first)); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m + i - 1; ++j) io::read(a[i][j]), id[i][j] = ++idx; s = ++idx, t = ++idx; task1::solve(); task2::solve(); task3::solve(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"https://leverimmy.top/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"网络流 24 题","slug":"网络流-24-题","permalink":"https://leverimmy.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-24-%E9%A2%98/"}]},{"title":"【洛谷】P4012 深海机器人问题","slug":"【洛谷】P4012-深海机器人问题","date":"2020-04-18T08:05:03.000Z","updated":"2020-07-03T08:36:44.747Z","comments":true,"path":"2020/04/18/【洛谷】P4012-深海机器人问题/","link":"","permalink":"https://leverimmy.top/2020/04/18/%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P4012-%E6%B7%B1%E6%B5%B7%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%97%AE%E9%A2%98/","excerpt":"题意简述：给定一个 $P \\cdot Q$ 的 网格图，点 $(x, y)$ 到 右方或上方的格子的 有向边 上有一定的价值，每个价值只会被计算一遍。 其中有 $a$ 个点 $(x_{1, i}, y_{1, i}) \\quad (i \\in [1, a])$ 会放出机器人，并且有 $b$ 个点 $(x_{2, i}, y_{2, i}) \\quad(i \\in [1, b])$ 可以回收机器人。 机器人必须被回收，求最大总价值。 $1 \\le P, Q \\le 15$，$1 \\le a \\le 4$，$1 \\le b \\le 6$。 题目链接","text":"题意简述：给定一个 $P \\cdot Q$ 的 网格图，点 $(x, y)$ 到 右方或上方的格子的 有向边 上有一定的价值，每个价值只会被计算一遍。 其中有 $a$ 个点 $(x_{1, i}, y_{1, i}) \\quad (i \\in [1, a])$ 会放出机器人，并且有 $b$ 个点 $(x_{2, i}, y_{2, i}) \\quad(i \\in [1, b])$ 可以回收机器人。 机器人必须被回收，求最大总价值。 $1 \\le P, Q \\le 15$，$1 \\le a \\le 4$，$1 \\le b \\le 6$。 题目链接 解题思路：考虑费用流模型。 把超级汇点连向所有能 放出 机器人的点，流量为 $a$，费用为 $0$； 把所有能 回收 机器人的点连向超级汇点，流量为 $b$，费用为 $0$。 然后是格点与格点之间的边，流量为 $\\inf$，费用为 $-c$。 这样，就能转化为最小费用最大流（其实最小费用的相反数就是最大价值）的模型了。 zkw 费用流的模板我就不贴了。 参考代码： Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;#define LL long long#define LOCALnamespace io &#123; template &lt;typename T&gt; inline void read(T &amp; _x) &#123; int f = 0, ch; _x = 0; while(!isdigit(ch = getchar())) f |= ch == '-'; while(isdigit(ch)) _x = _x * 10 + ch - '0', ch = getchar(); if(f) _x = -_x; &#125; template &lt;typename T, typename ... Args&gt; inline void read(T &amp;_f, Args&amp; ... args) &#123; read(_f), read(args ...); &#125; inline void _deal(char ch) &#123; putchar(ch); &#125; template &lt;typename T&gt; inline void _deal(T _x) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; if (_x &gt; 9) _deal(_x / 10); putchar(_x % 10 + '0'); &#125; inline void write() &#123;&#125; template &lt;typename T, typename ... Args&gt; inline void write(T _f, Args ... args) &#123; _deal(_f), write(args...); &#125;&#125;const int inf = 0x3f3f3f3f;const int N = 1e5 + 5;const int M = 1e5 + 5;int a, b, P, Q, s, t, min_cost, max_flow;int cnt, first[N];struct EDGE &#123; int to, _next, wt, ct;&#125; e[M &lt;&lt; 1];void Add_Edge(int u, int v, int w, int c) &#123; e[cnt].to = v, e[cnt].wt = w, e[cnt].ct = c, e[cnt]._next = first[u]; first[u] = cnt++;&#125;void Connect(int u, int v, int w, int c) &#123; Add_Edge(u, v, w, c); Add_Edge(v, u, 0, -c);&#125;int Id(int x, int y) &#123; return x * (Q + 1) + y;&#125;int main() &#123;#ifdef LOCAL freopen(\"robot.in\", \"r\", stdin); freopen(\"robot.out\", \"w\", stdout);#endif io::read(a, b, P, Q), s = (P + 1) * (Q + 1) + 1, t = (P + 1) * (Q + 1) + 2; memset(first, -1, sizeof(first)); for(int i = 0; i &lt;= P; ++i) &#123; for(int j = 0; j &lt; Q; ++j) &#123; int cost; io::read(cost); Connect(Id(i, j), Id(i, j + 1), 1, -cost); Connect(Id(i, j), Id(i, j + 1), inf, 0); &#125; &#125; for(int i = 0; i &lt;= Q; ++i) &#123; for(int j = 0; j &lt; P; ++j) &#123; int cost; io::read(cost); Connect(Id(j, i), Id(j + 1, i), 1, -cost); Connect(Id(j, i), Id(j + 1, i), inf, 0); &#125; &#125; for(int i = 1; i &lt;= a; ++i) &#123; int k, x, y; io::read(k, x, y); Connect(s, Id(x, y), k, 0); &#125; for(int i = 1; i &lt;= b; ++i) &#123; int r, x, y; io::read(r, x, y); Connect(Id(x, y), t, r, 0); &#125; zkw.solve(s, t); io::write(-min_cost); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"https://leverimmy.top/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"网络流 24 题","slug":"网络流-24-题","permalink":"https://leverimmy.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-24-%E9%A2%98/"}]},{"title":"【洛谷】P4014 分配问题","slug":"【洛谷】P4014-分配问题","date":"2020-04-17T06:44:51.000Z","updated":"2020-07-03T08:39:10.489Z","comments":true,"path":"2020/04/17/【洛谷】P4014-分配问题/","link":"","permalink":"https://leverimmy.top/2020/04/17/%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P4014-%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/","excerpt":"题意简述：有 $n$ 件事情要分给 $n$ 个人做，第 $i$ 个人做第 $j$ 件事情会得到 $a_{i, j}$ 的利润，求总利润的最大及最小值。 $1 \\le n \\le 100，-100 \\le a_{i, j} \\le 100$ 题目链接","text":"题意简述：有 $n$ 件事情要分给 $n$ 个人做，第 $i$ 个人做第 $j$ 件事情会得到 $a_{i, j}$ 的利润，求总利润的最大及最小值。 $1 \\le n \\le 100，-100 \\le a_{i, j} \\le 100$ 题目链接 解题思路：二分图的最大带权匹配模板题。 考虑使用费用流的方法（而不是二分图的相关算法）来解决这个问题。 建立超级源点，向每个人连一条流量为 $1$，费用为 $0$ 的边； 建立超级汇点，从每个事情连一条流量为 $1$，费用为 $0$ 的边。 第 $i$ 个人和第 $j$ 个事情间连一条 流量为 $1$，费用为 $a_{i, j}$ 的边。 这样可以保证每个人 仅会被使用一次。 至于最小带权匹配，边权取相反数即可。 参考代码： Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;#define LL long long// #define LOCALnamespace io &#123; template &lt;typename T&gt; inline void read(T &amp; _x) &#123; int f = 0, ch; _x = 0; while(!isdigit(ch = getchar())) f |= ch == '-'; while(isdigit(ch)) _x = _x * 10 + ch - '0', ch = getchar(); if(f) _x = -_x; &#125; template &lt;typename T, typename ... Args&gt; inline void read(T &amp;_f, Args&amp; ... args) &#123; read(_f), read(args ...); &#125; inline void _deal(char ch) &#123; putchar(ch); &#125; template &lt;typename T&gt; inline void _deal(T _x) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; if (_x &gt; 9) _deal(_x / 10); putchar(_x % 10 + '0'); &#125; inline void write() &#123;&#125; template &lt;typename T, typename ... Args&gt; inline void write(T _f, Args ... args) &#123; _deal(_f), write(args...); &#125;&#125;const int inf = 0x3f3f3f3f;const int N = 1e2 + 5;const int M = 1e5 + 5;int n, m, s, t, min_cost, ans1, ans2, a[N][N];int cnt, first[N * N];struct EDGE &#123; int to, _next, wt, ct;&#125; e[M &lt;&lt; 1];void Add_Edge(int u, int v, int w, int c) &#123; e[cnt].to = v, e[cnt].wt = w, e[cnt].ct = c, e[cnt]._next = first[u]; first[u] = cnt++;&#125;void Connect(int u, int v, int w, int c) &#123; Add_Edge(u, v, w, c); Add_Edge(v, u, 0, -c);&#125;struct ZKW &#123; static const int MS = N; int dis[MS], vis[MS]; bool spfa(int st, int ed) &#123; memset(vis, 0, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); std::queue &lt;int&gt; q; q.push(ed), vis[ed] = 1, dis[ed] = 0; while(!q.empty()) &#123; int x = q.front(); q.pop(), vis[x] = 0; for(int i = first[x]; ~i; i = e[i]._next) &#123; int y = e[i].to; if(e[i ^ 1].wt &amp;&amp; dis[y] &gt; dis[x] - e[i].ct) &#123; dis[y] = dis[x] - e[i].ct; if(!vis[y]) &#123; vis[y] = 1; q.push(y); &#125; &#125; &#125; &#125; return dis[st] ^ inf; &#125; int aug(int x, int in) &#123; vis[x] = 1; if(x == t) return in; int used = 0; for(int i = first[x]; ~i; i = e[i]._next) &#123; int y = e[i].to; if(!vis[y] &amp;&amp; e[i].wt &amp;&amp; dis[y] == dis[x] - e[i].ct) &#123; int cur_flow = aug(y, std::min(in - used, e[i].wt)); if(cur_flow) &#123; min_cost += cur_flow * e[i].ct; e[i].wt -= cur_flow; e[i ^ 1].wt += cur_flow; used += cur_flow; &#125; if(used == in) break; &#125; &#125; return used; &#125; void solve(int st, int ed) &#123; memset(vis, 0, sizeof(vis)); memset(dis, 0, sizeof(dis)); min_cost = 0; while(spfa(st, ed)) &#123; vis[ed] = 1; while(vis[ed]) &#123; memset(vis, 0, sizeof(vis)); aug(st, inf); &#125; &#125; &#125;&#125; zkw;void Build_Graph(int mul) &#123; memset(first, -1, sizeof(first)), cnt = 0; for(int i = 1; i &lt;= n; ++i) Connect(s, i, 1, 0); for(int i = n + 1; i &lt;= n + n; ++i) Connect(i, t, 1, 0); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) Connect(i, j + n, 1, a[i][j] * mul);&#125;int main() &#123;#ifdef LOCAL freopen(\"arrange.in\", \"r\", stdin); freopen(\"arrange.out\", \"w\", stdout);#endif io::read(n); s = 2 * n + 1, t = 2 * n + 2; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) io::read(a[i][j]); Build_Graph(1), zkw.solve(s, t); ans1 = min_cost; Build_Graph(-1), zkw.solve(s, t); ans2 = -min_cost; io::write(ans1, '\\n', ans2); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"https://leverimmy.top/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"网络流 24 题","slug":"网络流-24-题","permalink":"https://leverimmy.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-24-%E9%A2%98/"}]},{"title":"【洛谷】P1251 餐巾计划问题","slug":"【洛谷】P1251-餐巾计划问题","date":"2020-04-11T09:11:27.000Z","updated":"2020-07-03T08:40:27.718Z","comments":true,"path":"2020/04/11/【洛谷】P1251-餐巾计划问题/","link":"","permalink":"https://leverimmy.top/2020/04/11/%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P1251-%E9%A4%90%E5%B7%BE%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98/","excerpt":"题意简述：有一家餐厅，在接下来的 $N$ 天中，每天需要 $a_i$ 条餐巾。 每天你可以进行下列四种操作之一： 以 $p$ 元/条的单价购买新的毛巾（数量自选）； 延一天洗手上已有的毛巾（数量自选）； 将脏毛巾（数量自选）以 $f$ 元/条的单价送到慢洗店，$n$ 天后送回来； 将脏毛巾（数量自选）以 $s$ 元/条的单价送到快洗店，$m$ 天后送回来。 在第 $i$ 天买的餐巾可以供第 $j\\quad(j \\in [i + 1, N])$ 天使用，但 曾被用过的餐巾 在第二次用之前必须要洗一下。 餐厅需要保证每天 不能供不应需，求最小花费。 $1 \\le N \\le 10^3$，$1 \\le a_i \\le 10^9$。 题目链接","text":"题意简述：有一家餐厅，在接下来的 $N$ 天中，每天需要 $a_i$ 条餐巾。 每天你可以进行下列四种操作之一： 以 $p$ 元/条的单价购买新的毛巾（数量自选）； 延一天洗手上已有的毛巾（数量自选）； 将脏毛巾（数量自选）以 $f$ 元/条的单价送到慢洗店，$n$ 天后送回来； 将脏毛巾（数量自选）以 $s$ 元/条的单价送到快洗店，$m$ 天后送回来。 在第 $i$ 天买的餐巾可以供第 $j\\quad(j \\in [i + 1, N])$ 天使用，但 曾被用过的餐巾 在第二次用之前必须要洗一下。 餐厅需要保证每天 不能供不应需，求最小花费。 $1 \\le N \\le 10^3$，$1 \\le a_i \\le 10^9$。 题目链接 解题思路：这题的建模好有意思。 考虑拆点建模，每个点被分为了“起始点”（即 $S(i)$）和“结束点”（即 $E(i)$）两个点。 我们将在“起始点”考虑毛巾的输出，在“结束点”考虑毛巾的收集。 操作 1 即为从超级源点连向 $S(i)$，流量为 $\\inf$，费用为 $p$。因为我们能无限供应新的毛巾，而新的毛巾是 $p$ 元/条的。 操作 2 即为从某个点 $S(i)$ 直接连到 $S(i + 1)$。注意，这里我们是从起始点连向起始点，因为我们将在 $S(i + 1)$ 的时候考虑 $S(i)$ 延一天没洗的毛巾。 操作 3 即为从某个点 $S(i)$ 直接送到 $E(i + n)$，流量为 $\\inf$，费用为 $f$。因为我们将在第 $i + n$ 的末尾收到一些毛巾，而这些毛巾是 $f$ 元/条的。 操作 4 即为从某个点 $S(i)$ 直接送到 $E(i + m)$，流量为 $\\inf$，费用为 $s$。因为我们将在第 $i + m$ 的末尾收到一些毛巾，而这些毛巾是 $s$ 元/条的。 最后跑费用流即可，记得开 long long。 参考代码： Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#define LL long longnamespace io &#123; template &lt;typename T&gt; inline void read(T &amp; _x) &#123; int f = 0, ch; _x = 0; while(!isdigit(ch = getchar())) f |= ch == '-'; while(isdigit(ch)) _x = _x * 10 + ch - '0', ch = getchar(); if(f) _x = -_x; &#125; template &lt;typename T, typename ... Args&gt; inline void read(T &amp;_f, Args&amp; ... args) &#123; read(_f), read(args ...); &#125; inline void _deal(char ch) &#123; putchar(ch); &#125; template &lt;typename T&gt; inline void _deal(T _x) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; if (_x &gt; 9) _deal(_x / 10); putchar(_x % 10 + '0'); &#125; inline void write() &#123;&#125; template &lt;typename T, typename ... Args&gt; inline void write(T _f, Args ... args) &#123; _deal(_f), write(args...); &#125;&#125;const int oo = 0x3f3f3f3f;const int N = 1e5 + 5;const int M = 1e5 + 5;int n, c, a, p, b, q, S, T, cnt;int first[N], dis[N], inq[N], pre[N], arc[N], need[N];LL min_cost, flow[N];struct EDGE &#123; int to, _next, ct; LL wt;&#125; e[M];void Add_Edge(int u, int v, int w, int _c) &#123; e[cnt].to = v, e[cnt].wt = w, e[cnt].ct = _c, e[cnt]._next = first[u]; first[u] = cnt++; e[cnt].to = u, e[cnt].wt = 0, e[cnt].ct = -_c, e[cnt]._next = first[v]; first[v] = cnt++;&#125;bool spfa(int st, int ed) &#123; std::queue &lt;int&gt; q; while(!q.empty()) q.pop(); memset(inq, 0, sizeof(inq)); memset(dis, 0x3f, sizeof(dis)); memset(flow, 0x3f, sizeof(flow)); q.push(st), inq[st] = 1, dis[st] = 0, pre[ed] = -1; while(!q.empty()) &#123; int x = q.front(); q.pop(), inq[x] = 0; for(int i = first[x]; ~i; i = e[i]._next) &#123; int y = e[i].to; if(e[i].wt &gt; 0 &amp;&amp; dis[y] &gt; dis[x] + e[i].ct) &#123; dis[y] = dis[x] + e[i].ct; pre[y] = x, arc[y] = i; flow[y] = std::min(flow[x], e[i].wt); if(!inq[y]) &#123; q.push(y), inq[y] = 1; &#125; &#125; &#125; &#125; return ~pre[ed];&#125;void mcmf() &#123; while(spfa(S, T)) &#123; min_cost += 1LL * flow[T] * dis[T]; for(int i = T; i != S; i = pre[i]) &#123; e[ arc[i] ].wt -= flow[T]; e[ arc[i] ^ 1 ].wt += flow[T]; &#125; &#125;&#125;int main() &#123; io::read(n), S = 0, T = n &lt;&lt; 1 | 1; memset(first, -1, sizeof(first)); for(int i = 1; i &lt;= n; ++i) io::read(need[i]); io::read(c, a, p, b, q); for(int i = 1; i &lt;= n; ++i) &#123; Add_Edge(S, i, need[i], 0); // 起始点 Add_Edge(i + n, T, need[i], 0); // 结束点 Add_Edge(S, i + n, oo, c); // 买新的餐巾 if(i + 1 &lt;= n) Add_Edge(i, i + 1, oo, 0); // 拖到明天 if(i + a &lt;= n) Add_Edge(i, i + a + n, oo, p); // 快洗店 if(i + b &lt;= n) Add_Edge(i, i + b + n, oo, q); // 慢洗店 &#125; mcmf(); io::write(min_cost); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"https://leverimmy.top/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"网络流 24 题","slug":"网络流-24-题","permalink":"https://leverimmy.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-24-%E9%A2%98/"}]},{"title":"【文化课】数列不动点浅探","slug":"【文化课】数列不动点浅探","date":"2020-04-08T10:08:00.000Z","updated":"2020-07-03T08:25:12.052Z","comments":true,"path":"2020/04/08/【文化课】数列不动点浅探/","link":"","permalink":"https://leverimmy.top/2020/04/08/%E3%80%90%E6%96%87%E5%8C%96%E8%AF%BE%E3%80%91%E6%95%B0%E5%88%97%E4%B8%8D%E5%8A%A8%E7%82%B9%E6%B5%85%E6%8E%A2/","excerpt":"数列不动点可以辅助我们快速解题。","text":"数列不动点可以辅助我们快速解题。 基础知识定义 已知函数 $f(x)$，若存在 $x_0$ 使得 $f(x_0) = x_0$，则称 $x_0$ 为 $f(x)$ 的一个不动点。 若数列 $\\{a_n\\}$ 满足 $a_{n + 1} = g(a_n) \\quad(n \\in \\mathbb{N}^{*})$，则称 $g(x)$ 为数列 $\\{a_n\\}$ 的递推函数。 定理一若 $f(x) = ax + b\\quad(a \\notin \\{0, 1\\})$ 为数列 $\\{a_n\\}$ 的递推函数，且 $p$ 为 $f(x)$ 的不动点，则数列 $\\{a_n - p\\}$ 为公比为 $a$ 的等比数列。 证明 $\\because$ $p$ 为 $f(x)$ 的不动点$\\therefore p = f(p) = ap + b$，即 $b - p = -ap$又 $a_{n + 1} = f(a_n) = a\\cdot a_n + b$$\\begin{aligned}\\therefore a_{n + 1} - p &amp; = a\\cdot a_n + b - p \\\\ &amp; = a\\cdot a_n - ap \\\\ &amp; = a(a_n - p)\\end{aligned}$$\\therefore$ $\\{a_n - p\\}$ 为公比为 $a$ 的等比数列 定理二 若 $f(x) = \\dfrac{ax + b}{cx + d}\\quad(c \\neq 0, ad - bc \\neq 0)$ 为数列 $\\{a_n\\}$ 的递推函数，且 $p, q$ 为 $f(x)$ 的两 相异 不动点，则数列 $\\{\\dfrac{a_n - p}{a_n - q}\\}$ 为公比为 $\\dfrac{a - pc}{a - qc}$ 的等比数列。 证明 由 $x = f(x) = \\dfrac{ax + b}{cx + d}$ 知 $cx^2 + (d - a)x - b = 0$将 $x_1 = p, x_2 = q$ 代入得 $\\begin{cases}cp^2 + (d - a)p - b = 0 \\\\ cq^2 + (d - a)q - b = 0\\end{cases}$整理得 $\\begin{cases}p = \\dfrac{pd - b}{a - pc} \\\\ q = \\dfrac{qd - b}{a - qc}\\end{cases}$$\\begin{aligned}\\therefore \\dfrac{a_{n + 1} - p}{a_{n + 1} - q} &amp; = \\dfrac{\\dfrac{a\\cdot a_n + b}{c\\cdot a_n + d} - p}{\\dfrac{a\\cdot a_n + b}{c\\cdot a_n + d} - q} \\\\ &amp; = \\dfrac{(a - pc)a_n + b - pd}{(a - qc)a_n + b - qd} \\\\ &amp; = \\dfrac{a - pc}{a - qc} \\cdot \\dfrac{a_n - \\dfrac{pd - b}{a - pc}}{a_n - \\dfrac{qd - b}{a - qc}} \\\\ &amp; = \\dfrac{a_n - p}{a_n - q}\\cdot\\dfrac{a - pc}{a - qc}\\end{aligned}$$\\therefore$ $\\{\\dfrac{a_n - p}{a_n - q}\\}$ 为公比为 $\\dfrac{a - pc}{a - qc}$ 的等比数列 若 $f(x) = \\dfrac{ax + b}{cx + d}\\quad(c \\neq 0, ad - bc \\neq 0)$ 为数列 $\\{a_n\\}$ 的递推函数，且 $p$ 为 $f(x)$ 的 唯一 不动点，则数列 $\\{\\dfrac{1}{a_n - p}\\}$ 为公差为 $\\dfrac{2c}{a + d}$ 的等差数列。 证明 由 $x = f(x) = \\dfrac{ax + b}{cx + d}$ 知 $cx^2 + (d - a)x - b = 0$$\\therefore cp^2 + (d - a)p - b = 0$，即 $b - pd = cp^2 - ap$$\\begin{aligned}\\therefore \\dfrac{1}{a_{n + 1} - p} &amp; = \\dfrac{1}{\\dfrac{a\\cdot a_n + b}{c\\cdot a_n + d} - p} \\\\ &amp; = \\dfrac{c\\cdot a_n + d}{(a - cp)\\cdot a_n + b - pd} \\\\ &amp; = \\dfrac{c\\cdot a_n + d}{(a - cp)\\cdot a_n + cp^2 - ap} \\\\ &amp; = \\dfrac{c\\cdot a_n + d}{(a - cp)(a_n - p)} \\\\ &amp; = \\dfrac{1}{a - cp}\\cdot\\dfrac{c(a_n - p) + cp + d}{a_n - p} \\\\ &amp; = \\dfrac{c}{a - cp} + \\dfrac{cp + d}{a - cp}\\cdot\\dfrac{1}{a_n - p} \\\\ &amp; = \\dfrac{1}{a_n - p} + \\dfrac{2c}{a + d}\\end{aligned}$$\\therefore$ $\\{\\dfrac{1}{a_n - p}\\}$ 为公差为 $\\dfrac{2c}{a + d}$ 的等差数列 定理三若 $f(x) = \\dfrac{ax^2 + bx + c}{ex + f}$ 为数列 $\\{a_n\\}$ 的递推函数，且 $p, q$ 为 $f(x)$ 的两 相异 不动点，则 当且仅当 $b = 0, e = 2a$ 时有 $\\dfrac{a_{n + 1} - p}{a_{n + 1} - q} = (\\dfrac{a_n - p}{a_n - q})^2$。 证明 $\\because$ $p, q$ 为 $f(x)$ 的两相异不动点$\\therefore \\begin{cases}c - pf = (e - a)p^2 - bp \\\\ c - qf = (e - a)q^2 - bq\\end{cases}$$\\begin{aligned}\\therefore \\dfrac{a_{n + 1} - p}{a_{n + 1} - q} &amp; = \\dfrac{a\\cdot a_n^2 + b\\cdot a_n + c - p(e\\cdot a_n + f)}{a\\cdot a_n^2 + b\\cdot a_n + c - q(e\\cdot a_n + f)} \\\\ &amp; = \\dfrac{a\\cdot a_n^2 + (b - ep)\\cdot a_n + c - pf}{a\\cdot a_n^2 + (b - eq)\\cdot a_n + c - qf} \\\\ &amp; = \\dfrac{a\\cdot a_n^2 + (b - ep)\\cdot a_n + (e - a)\\cdot p^2 - bp}{a\\cdot a_n^2 - (b - eq)\\cdot a_n + (e - a)\\cdot q^2 - bq}\\end{aligned}$$\\begin{aligned}\\therefore \\dfrac{a_{n + 1} - p}{a_{n + 1} - q} = (\\dfrac{a_n - p}{a_n - q})^2 &amp; \\iff \\dfrac{a\\cdot a_n^2 + (b - ep)\\cdot a_n + (e - a)\\cdot p^2 - bp}{a\\cdot a_n^2 - (b - eq)\\cdot a_n + (e - a)\\cdot q^2 - bq} = \\dfrac{a_n^2 - 2p\\cdot a_n + p^2}{a_n^2 - 2q\\cdot a_n + q^2} \\\\ &amp; \\iff \\begin{cases}b - ep = -2ap \\\\ b - eq = -2aq\\end{cases} \\\\ &amp; \\iff \\begin{cases}(2a - e)p + b = 0 \\\\ (2a - e)q + b = 0\\end{cases} \\\\ &amp; \\iff \\begin{cases}b = 0 \\\\ e = 2a\\end{cases} \\quad(p \\neq q)\\end{aligned}$ 例题讲解例1设数列 $\\{a_n\\}$ 满足 $a_1 = 1, a_{n + 1} = \\dfrac{a_n + 2}{a_n}$，求数列 $\\{a_n\\}$ 的通项公式。 解析 特征方程为 $x = \\dfrac{x + 2}{x}$，解得 $x_1 = -1, x_2 = 2$$\\therefore$ $\\{\\dfrac{a_n + 1}{a_n - 2}\\}$ 为首项为 $-2$，公比为 $-2$ 的等比数列$\\therefore \\dfrac{a_n +1}{a_n - 2} = (-2)^n$$\\therefore a_n = \\dfrac{2\\cdot (-2)^n +1}{(-2)^n - 1}$ 例2数列 $\\{a_n\\}$ 满足下列关系：$a_1 = 2a, a_{n + 1} = 2a - \\dfrac{a^2}{a_n}\\quad(a \\neq 0)$，求数列 $\\{a_n\\}$ 的通项公式。 解析 特征方程为 $x = \\dfrac{2ax - a^2}{x}$，解得 $x_1 = x_2 = a$$\\therefore$ $\\{\\dfrac{1}{a_n - a}\\}$ 为首项为 $\\dfrac{1}{a}$，公比为 $\\dfrac{1}{a}$ 的等比数列$\\therefore \\dfrac{1}{a_n - a} = \\dfrac{n}{a}$$\\therefore a_n = \\dfrac{a + na}{n}$ 例3已知数列 $\\{a_n\\}$ 满足 $a_1 = 2, a_{n + 1} = \\dfrac{a_n^2 + 2}{2a_n}$，求数列 $\\{a_n\\}$ 的通项公式。 解析 特征方程为 $x = \\dfrac{x^2 + 2}{2x}$，解得 $x_1 = \\sqrt{2}, x_2 = -\\sqrt{2}$$\\therefore \\dfrac{a_{n + 1} - \\sqrt{2}}{a_{n + 1} + \\sqrt{2}} = (\\dfrac{a_n - \\sqrt{2}}{a_n + \\sqrt{2}})^2$$\\therefore \\dfrac{a_n - \\sqrt{2}}{a_n + \\sqrt{2}} = (3 - 2\\sqrt{2})^{2^{n - 1}} = (\\sqrt{2} - 1)^{2^n}$$\\therefore a_n = \\sqrt{2}\\cdot\\dfrac{1 + (\\sqrt{2} - 1)^{2^n}}{1 - (\\sqrt{2} - 1)^{2^n}}$ 总结就是套公式。","categories":[{"name":"文化课","slug":"文化课","permalink":"https://leverimmy.top/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"数学","slug":"文化课/数学","permalink":"https://leverimmy.top/categories/%E6%96%87%E5%8C%96%E8%AF%BE/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://leverimmy.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数列","slug":"数列","permalink":"https://leverimmy.top/tags/%E6%95%B0%E5%88%97/"}]},{"title":"【洛谷】P4015 运输问题","slug":"【洛谷】P4015-运输问题","date":"2020-04-07T15:10:51.000Z","updated":"2020-07-03T08:04:47.496Z","comments":true,"path":"2020/04/07/【洛谷】P4015-运输问题/","link":"","permalink":"https://leverimmy.top/2020/04/07/%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P4015-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/","excerpt":"题意简述：给定两个长度分别为 $m$ 和 $n$ 的序列 $A$ 和 $B$， 每次操作，使 $A_i \\gets A_i - 1$，且 $B_j \\gets B_j + 1$ 有代价 $C_{i, j}$， 求使得 $\\sum_{j = 1}^{m}A_j = \\sum_{j = 1}^{n}B_j$ 的最小费用。 $1 \\le m, n \\le 100$。 题目链接","text":"题意简述：给定两个长度分别为 $m$ 和 $n$ 的序列 $A$ 和 $B$， 每次操作，使 $A_i \\gets A_i - 1$，且 $B_j \\gets B_j + 1$ 有代价 $C_{i, j}$， 求使得 $\\sum_{j = 1}^{m}A_j = \\sum_{j = 1}^{n}B_j$ 的最小费用。 $1 \\le m, n \\le 100$。 题目链接 解题思路：建立超级源点，连向序列 $A_i$，流量为 $A_i$，费用为 $0$，表示有这么多的储存量； 再建立超级汇点，连向序列 $B_i$，流量为 $B_i$，费用为 $0$，表示需要这么多的货物。 第一问，$A_i$ 到 $B_j$ 连一条容量为 $B_j$，费用为 $C_{i, j}$ 的边，然后跑费用流求最小费用即可； 第二问，$A_i$ 到 $B_j$ 连一条容量为 $B_j$，费用为 $-C_{i, j}$ 的边，然后跑费用流求最小费用即可。 参考代码： Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;#define LL long longnamespace io &#123; template &lt;typename T&gt; inline void read(T &amp; _x) &#123; int f = 0, ch; _x = 0; while(!isdigit(ch = getchar())) f |= ch == '-'; while(isdigit(ch)) _x = _x * 10 + ch - '0', ch = getchar(); if(f) _x = -_x; &#125; template &lt;typename T, typename ... Args&gt; inline void read(T &amp;_f, Args&amp; ... args) &#123; read(_f), read(args ...); &#125; inline void _deal(char ch) &#123; putchar(ch); &#125; template &lt;typename T&gt; inline void _deal(T _x) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; if (_x &gt; 9) _deal(_x / 10); putchar(_x % 10 + '0'); &#125; inline void write() &#123;&#125; template &lt;typename T, typename ... Args&gt; inline void write(T _f, Args ... args) &#123; _deal(_f), write(args...); &#125;&#125;const int oo = 0x3f3f3f3f;const int N = 1e5 + 5;const int M = 1e5 + 5;int n, m, S, T, cnt, min_cost;int first[N], inq[N], a[N], b[N], dis[N], flow[N], pre[N], arc[N], d[110][110];struct EDGE &#123; int to, _next, wt, ct;&#125; e[M &lt;&lt; 1];void Add_Edge(int u, int v, int w, int c) &#123; e[cnt].to = v, e[cnt].wt = w, e[cnt].ct = c, e[cnt]._next = first[u]; first[u] = cnt++;&#125;bool spfa(int st, int ed) &#123; std::queue &lt;int&gt; q; memset(inq, 0, sizeof(inq)); memset(dis, 0x3f, sizeof(dis)); memset(flow, 0x3f, sizeof(flow)); q.push(st), dis[st] = 0, inq[st] = 1, pre[ed] = -1; while (!q.empty()) &#123; int x = q.front(); q.pop(), inq[x] = 0; for (int i = first[x]; ~i; i = e[i]._next) &#123; int y = e[i].to; if (e[i].wt &gt; 0 &amp;&amp; dis[y] &gt; dis[x] + e[i].ct) &#123; dis[y] = dis[x] + e[i].ct; pre[y] = x, arc[y] = i; flow[y] = std::min(flow[x], e[i].wt); if (!inq[y]) q.push(y), inq[y] = 1; &#125; &#125; &#125; return ~pre[ed];&#125;void MCMF() &#123; while(spfa(S, T)) &#123; min_cost += flow[T] * dis[T]; for(int i = T; i != S; i = pre[i]) &#123; e[ arc[i] ].wt -= flow[T]; e[ arc[i] ^ 1 ].wt += flow[T]; &#125; &#125;&#125;void Build(int mul) &#123; memset(first, -1, sizeof(first)); cnt = min_cost = 0; for(int i = 1; i &lt;= m; ++i) &#123; Add_Edge(S, i, a[i], 0); Add_Edge(i, S, 0, 0); &#125; for(int i = 1; i &lt;= n; ++i) &#123; Add_Edge(i + m, T, b[i], 0); Add_Edge(T, i + m, 0, 0); &#125; for(int i = 1; i &lt;= m; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; Add_Edge(i, j + m, b[j], d[i][j] * mul); Add_Edge(j + m, i, 0, -d[i][j] * mul); &#125; &#125;&#125;int main() &#123; io::read(m, n); S = 0, T = 2001; for(int i = 1; i &lt;= m; ++i) io::read(a[i]); for(int i = 1; i &lt;= n; ++i) io::read(b[i]); for(int i = 1; i &lt;= m; ++i) for(int j = 1; j &lt;= n; ++j) io::read(d[i][j]); Build(1); MCMF(); io::write(min_cost, '\\n'); Build(-1); MCMF(); io::write(-min_cost); return 0;&#125;/*2 3220 280170 120 21077 39 105150 186 122*/","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"费用流","slug":"费用流","permalink":"https://leverimmy.top/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"网络流 24 题","slug":"网络流-24-题","permalink":"https://leverimmy.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-24-%E9%A2%98/"}]},{"title":"【洛谷】P6216 回文匹配","slug":"【洛谷】P6216-回文匹配","date":"2020-04-06T00:59:24.000Z","updated":"2020-07-03T08:30:52.087Z","comments":true,"path":"2020/04/06/【洛谷】P6216-回文匹配/","link":"","permalink":"https://leverimmy.top/2020/04/06/%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P6216-%E5%9B%9E%E6%96%87%E5%8C%B9%E9%85%8D/","excerpt":"题意简述：给定 $S, T$，求 $T$ 在 $S$ 的所有奇数长度的回文子串中出现的次数之和。 $1\\le\\left|S\\right|, \\left|T\\right| \\le 3\\cdot10^6$。 题目链接","text":"题意简述：给定 $S, T$，求 $T$ 在 $S$ 的所有奇数长度的回文子串中出现的次数之和。 $1\\le\\left|S\\right|, \\left|T\\right| \\le 3\\cdot10^6$。 题目链接 解题思路：记 $n = \\left|S\\right|, m = \\left|T\\right|$。 在回文树上，从长度为 $-1$ 的虚拟节点 $1$ 开始 dfs，即可遍历所有奇数长度的回文子串。 注意到，即使回文树上的某个点对应的回文串在 $S$ 中多次出现，其本质上是相同的。 我们考虑记录一下每个回文串在 $S$ 中对应的右界，并用 KMP 处理出 $T$ 在 $S$ 的每一个前缀中出现的次数。 利用差分的思想，$T$ 在 $S[l..r]$ 中出现的次数就是 $sum_r - sum_{l + m - 2}$ 答案即为 $$ \\sum_{u \\in \\text{subtree of node }1}(sum_r - sum_{l + m - 2})\\cdot cnt_u$$ 参考代码： Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;#define LL long long#define uint64 unsigned intconst int N = 3e6 + 5;const int C = 26 + 5;int n, m, sum[N], _next[N];char str1[N], str2[N];uint64 ans;struct EERTREE &#123; static const int MS = N; int n; int last; int cntNode; int len[MS]; int R[MS]; int cnt[MS]; int link[MS]; int ch[MS][C]; int make(int l) &#123; len[cntNode] = l; return cntNode++; &#125; int GetFail(int x) &#123; while(str1[n] != str1[n - len[x] - 1]) x = link[x]; return x; &#125; void extend(int x) &#123; ++n; int fa = GetFail(last); if(!ch[fa][x]) &#123; int now = make(len[fa] + 2); link[now] = ch[ GetFail(link[fa]) ][x]; ch[fa][x] = now; &#125; last = ch[fa][x]; R[last] = n; ++cnt[last]; &#125; void init() &#123; n = cntNode = last = 0; make(0), make(-1); link[0] = 1, link[1] = 0; str1[0] = -1; &#125; void refresh() &#123; for(int i = cntNode - 1; i &gt;= 0; --i) cnt[ link[i] ] += cnt[i]; &#125; void dfs(int x) &#123; if(len[x] &gt;= m) ans += (sum[ R[x] ] - sum[ R[x] - len[x] + m - 1]) * cnt[x]; for(int i = 1; i &lt;= C; ++i) if (ch[x][i]) dfs(ch[x][i]); &#125; EERTREE() &#123; init(); &#125;&#125; t;void Get_Next(char *S, int len) &#123; for(int i = 1, j = 0; i &lt; len; ++i, j = _next[i]) &#123; while(j &gt; 0 &amp;&amp; S[i + 1] != S[j + 1]) j = _next[j]; if(S[i + 1] == S[j + 1]) j++; _next[i + 1] = j; &#125;&#125;void KMP(char *S, int len1, char *T, int len2) &#123; for(int i = 0, j = 0; i &lt;= len1; ) &#123; if(j == len2) sum[i] = 1; if(S[i + 1] == T[j + 1]) ++i, ++j; else &#123; if (j == 0) ++i; else j = _next[j]; &#125; &#125;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); scanf(\"%s %s\", str1 + 1, str2 + 1); Get_Next(str2, m); KMP(str1, n, str2, m); for(int i = 1; i &lt;= n; ++i) sum[i] += sum[i - 1]; for(int i = 1; i &lt;= n; ++i) t.extend(str1[i] - 'a' + 1); t.refresh(); t.dfs(1); printf(\"%u\", ans); return 0;&#125;/*10 2ccbccbbcbb bc20 2cbcaacabcbacbbabacca ba*/","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"回文树","slug":"回文树","permalink":"https://leverimmy.top/tags/%E5%9B%9E%E6%96%87%E6%A0%91/"},{"name":"KMP","slug":"KMP","permalink":"https://leverimmy.top/tags/KMP/"},{"name":"前缀和","slug":"前缀和","permalink":"https://leverimmy.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"差分","slug":"差分","permalink":"https://leverimmy.top/tags/%E5%B7%AE%E5%88%86/"}]},{"title":"【置顶】近期的小计划","slug":"【置顶】近期的小计划","date":"2020-03-30T14:43:30.000Z","updated":"2020-07-03T08:20:39.806Z","comments":true,"path":"2020/03/30/【置顶】近期的小计划/","link":"","permalink":"https://leverimmy.top/2020/03/30/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E8%BF%91%E6%9C%9F%E7%9A%84%E5%B0%8F%E8%AE%A1%E5%88%92/","excerpt":"众所周知，$\\text{Clever_Jimmy}$ 是只鸽子。","text":"众所周知，$\\text{Clever_Jimmy}$ 是只鸽子。 OI 相关字符串 KMP 复习 AC 自动机 后缀树 后缀数组 最小表示法 回文树 2020.06.26 完成 图论 矩阵树定理 最小树形图 点双/边双 2-SAT 欧拉路径 三元环 Prufer 序列 强连通分量 数据结构 K-D Tree 笛卡尔树 动态树 数学 类欧几里得算法 2020.05.05 完成 中国剩余定理 BSGS 卢卡斯定理 莫比乌斯反演 杜教筛 Min_25 筛 FFT NTT 拉格朗日插值 FWT 线性基 高斯消元 二项式反演 动态规划 区间dp 2020.05.01 完成 树型dp 2020.05.02 完成 状压dp 2020.05.03 完成 数位dp 单调队列优化dp 斜率优化dp 四边形不等式优化dp 插头dp 动态dp 计算几何 叉乘 凸包 扫描线 旋转卡壳 半平面交 杂项 01 分数规划 悬线法 CDQ 分治 整体二分 Karatsuba 乘法 2020.05.04 完成","categories":[{"name":"备忘录","slug":"备忘录","permalink":"https://leverimmy.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"},{"name":"计划","slug":"备忘录/计划","permalink":"https://leverimmy.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/%E8%AE%A1%E5%88%92/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://leverimmy.top/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"【洛谷】P3649 [APIO2014]回文串","slug":"【洛谷】P3649-APIO2014-回文串","date":"2020-03-27T03:49:44.000Z","updated":"2020-07-03T08:34:34.260Z","comments":true,"path":"2020/03/27/【洛谷】P3649-APIO2014-回文串/","link":"","permalink":"https://leverimmy.top/2020/03/27/%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P3649-APIO2014-%E5%9B%9E%E6%96%87%E4%B8%B2/","excerpt":"题意简述：给定一个字符串 $S$，求其所有回文子串的出现次数与其长度的乘积之和。 $1 \\le \\left|S\\right| \\le 3\\cdot10^5$。 题目链接","text":"题意简述：给定一个字符串 $S$，求其所有回文子串的出现次数与其长度的乘积之和。 $1 \\le \\left|S\\right| \\le 3\\cdot10^5$。 题目链接 解题思路：直接对 $S$ 建造回文树，最终 $\\max_{i \\in T}\\{len_i\\cdot occ_i\\}$ 即为所求。 参考代码： Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;#define LL long longnamespace io &#123; template &lt;typename T&gt; inline void read(T &amp; _x) &#123; int f = 0, ch; _x = 0; while(!isdigit(ch = getchar())) f |= ch == '-'; while(isdigit(ch)) _x = _x * 10 + ch - '0', ch = getchar(); if(f) _x = -_x; &#125; template &lt;typename T, typename ... Args&gt; inline void read(T &amp;_f, Args&amp; ... args) &#123; read(_f), read(args ...); &#125; inline void _deal(char ch) &#123; putchar(ch); &#125; template &lt;typename T&gt; inline void _deal(T _x) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; if (_x &gt; 9) _deal(_x / 10); putchar(_x % 10 + '0'); &#125; inline void write() &#123;&#125; template &lt;typename T, typename ... Args&gt; inline void write(T _f, Args ... args) &#123; _deal(_f), write(args...); &#125;&#125;const int N = 3e5 + 5;const int C = 26 + 5;int m;LL ans;char str[N];struct EERTREE &#123; int n; // 已处理的字符串长度 int cntNode; // 结点个数 int last; // 指向字符串中，上一个字符为结尾的最长回文串 int s[N]; // 已处理的字符串 int len[N]; // 点 i 表示的回文串的长度 int ch[N][C]; // 边集 int link[N]; // 回文后缀链接 int occ[N]; // 点 i 表示的回文串出现的次数// int num[N]; // link[i] 最多能迭代的次数 int make(int l) &#123; // 生成一个长度为 l 的新点 for(int i = 0; i &lt; C; ++i) ch[cntNode][i] = 0; occ[cntNode] = 0;// num[cntNode] = 0; len[cntNode] = l; return cntNode++; &#125; int getfail(int x) &#123; // 暴力回溯指针 while(s[n - len[x] - 1] != s[n]) x = link[x]; return x; &#125; void add(int c) &#123; s[++n] = c; int fa = getfail(last); // last 的在树中的父结点 if(!ch[fa][c]) &#123; int now = make(len[fa] + 2); link[now] = ch[ getfail(link[fa]) ][c]; ch[fa][c] = now;// num[now] = num[ link[now] ] + 1; &#125; last = ch[fa][c]; ++occ[last]; &#125; void refresh() &#123; for(int i = cntNode - 1; i &gt;= 0; --i) occ[ link[i] ] += occ[i]; &#125; EERTREE() &#123; cntNode = n = last = 0; make(0), make(-1); // 长度分别为偶数、奇数的两个根 s[0] = -1, link[0] = 1; &#125;&#125; t;int main() &#123; scanf(\"%s\", str + 1); m = strlen(str + 1); for(int i = 1; i &lt;= m; ++i) t.add(str[i] - 'a' + 1); t.refresh(); for(int i = 0; i &lt; t.cntNode; ++i) ans = std::max(ans, 1LL * t.len[i] * t.occ[i]); io::write(ans); return 0;&#125;/*abacaba*/","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"回文树","slug":"回文树","permalink":"https://leverimmy.top/tags/%E5%9B%9E%E6%96%87%E6%A0%91/"},{"name":"字符串","slug":"字符串","permalink":"https://leverimmy.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【洛谷】P3355 骑士共存问题","slug":"【洛谷】P3355-骑士共存问题","date":"2020-03-26T13:19:40.000Z","updated":"2020-07-03T08:45:45.036Z","comments":true,"path":"2020/03/26/【洛谷】P3355-骑士共存问题/","link":"","permalink":"https://leverimmy.top/2020/03/26/%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P3355-%E9%AA%91%E5%A3%AB%E5%85%B1%E5%AD%98%E9%97%AE%E9%A2%98/","excerpt":"题意简述：给定一个大小为 $n \\times n$ 的棋盘，其中 $m$ 个格子上有障碍，问最多能放多少个骑士（即「马」）。 $1 \\le n \\le 200$，$0 \\le m \\le n^2$。 题目链接","text":"题意简述：给定一个大小为 $n \\times n$ 的棋盘，其中 $m$ 个格子上有障碍，问最多能放多少个骑士（即「马」）。 $1 \\le n \\le 200$，$0 \\le m \\le n^2$。 题目链接 解题思路：还是考虑奇偶建图。 所有棋盘上的白点是不会互相攻击到的，所有黑点也是。 于是超级源点与所有白点连一条流量为 $1$ 的边，所有黑点与超级汇点连一条流量为 $1$ 的边。 两个 会互相攻击到的 点之间连一条流量为 $\\inf$ 的边。 特殊地，有障碍的格子不连任何边。 题目要求 最多 能放多少个马，就用 $n^2 - m$ 减去最大流即可。 参考代码： Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;#define LL long longnamespace io &#123; template &lt;typename T&gt; inline void read(T &amp; _x) &#123; int f = 0, ch; _x = 0; while(!isdigit(ch = getchar())) f |= ch == '-'; while(isdigit(ch)) _x = _x * 10 + ch - '0', ch = getchar(); if(f) _x = -_x; &#125; template &lt;typename T, typename ... Args&gt; inline void read(T &amp;_f, Args&amp; ... args) &#123; read(_f), read(args ...); &#125; inline void _deal(char ch) &#123; putchar(ch); &#125; template &lt;typename T&gt; inline void _deal(T _x) &#123; if (_x &lt; 0) putchar('-'), _x = -_x; if (_x &gt; 9) _deal(_x / 10); putchar(_x % 10 + '0'); &#125; inline void write() &#123;&#125; template &lt;typename T, typename ... Args&gt; inline void write(T _f, Args ... args) &#123; _deal(_f), write(args...); &#125;&#125;const int oo = 0x3f3f3f3f;const int N = 2e5 + 5;const int M = 1e6 + 5;const int C = 2e2 + 5;const int dx[8]=&#123;-2, -1, 1, 2, 2, 1, -1, -2&#125;;const int dy[8]=&#123;-1, -2, -2, -1, 1, 2, 2, 1&#125;;int n, m, s, t, cnt, max_flow, first[N], cur[N], dep[N], E[C][C];struct EDGE &#123; int to, _next, wt;&#125; e[M &lt;&lt; 1];void Add_Edge(int u, int v, int w) &#123; e[cnt].to = v, e[cnt].wt = w, e[cnt]._next = first[u]; first[u] = cnt++;&#125;bool bfs(int S, int T) &#123; std::queue &lt;int&gt; q; memset(dep, 0, sizeof(dep)); q.push(S), dep[S] = 1; while(!q.empty()) &#123; int x = q.front(); q.pop(); for(int i = first[x]; ~i; i = e[i]._next) &#123; int y = e[i].to; if(!dep[y] &amp;&amp; e[i].wt) &#123; dep[y] = dep[x] + 1; q.push(y); if(y == T) return 1; &#125; &#125; &#125; return 0;&#125;int dinic(int x, int in) &#123; if(x == t) return in; int out = in; for(int &amp;i = cur[x]; ~i &amp;&amp; out; i = e[i]._next) &#123; int y = e[i].to; if(e[i].wt &amp;&amp; dep[y] == dep[x] + 1) &#123; int cur_flow = dinic(y, std::min(e[i].wt, out)); if(!cur_flow) dep[y] = 0; e[i].wt -= cur_flow; e[i ^ 1].wt += cur_flow; out -= cur_flow; &#125; &#125; return in - out;&#125;int id(int x, int y) &#123; return (x - 1) * n + y; &#125;bool valid(int x, int y) &#123; return !E[x][y] &amp;&amp; x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= n; &#125;int main() &#123; io::read(n, m); memset(first, -1, sizeof(first)); s = 0, t = n * n + 1; for(int i = 1; i &lt;= m; ++i) &#123; int x, y; io::read(x, y); E[x][y] = 1; &#125; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) if(!E[i][j]) &#123; if((i + j) % 2 == 0) &#123; Add_Edge(s, id(i, j), 1); Add_Edge(id(i, j), s, 0); &#125; else &#123; Add_Edge(id(i, j), t, 1); Add_Edge(t, id(i, j), 0); &#125; &#125; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) if((i + j) % 2 == 0) &#123; for(int k = 0; k &lt; 8; ++k) &#123; int nx = i + dx[k], ny = j + dy[k]; if(valid(nx, ny)) &#123; Add_Edge(id(i, j), id(nx, ny), oo); Add_Edge(id(nx, ny), id(i, j), 0); &#125; &#125; &#125; &#125; while(bfs(s, t)) &#123; memcpy(cur, first, sizeof(first)); max_flow += dinic(s, oo); &#125; io::write(n * n - m - max_flow); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"网络流 24 题","slug":"网络流-24-题","permalink":"https://leverimmy.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-24-%E9%A2%98/"},{"name":"网络流","slug":"网络流","permalink":"https://leverimmy.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最大流","slug":"最大流","permalink":"https://leverimmy.top/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"Dinic","slug":"Dinic","permalink":"https://leverimmy.top/tags/Dinic/"}]},{"title":"【洛谷】P4430 小猴打架","slug":"【洛谷】P4430-小猴打架","date":"2020-03-19T01:10:07.000Z","updated":"2020-07-03T08:31:58.397Z","comments":true,"path":"2020/03/19/【洛谷】P4430-小猴打架/","link":"","permalink":"https://leverimmy.top/2020/03/19/%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P4430-%E5%B0%8F%E7%8C%B4%E6%89%93%E6%9E%B6/","excerpt":"题意简述：求点数为 $n$ 的完全图中，构成生成树的不同连接方式的方案数。 $1 \\le n \\le 10^6$。 题目链接","text":"题意简述：求点数为 $n$ 的完全图中，构成生成树的不同连接方式的方案数。 $1 \\le n \\le 10^6$。 题目链接 解题思路：一共有 $n$ 个点，你只能选 $n - 1$ 个点，每个点向外连一条边。 每个点向外有 $n - 1$ 条边，那么构成一个有 $n$ 个点的树的方案数为 $n^{n - 2}$。 生成这个有 $n - 1$ 条边的树的方案数为 $(n - 1)!$。 所以答案为 $(n - 1)!\\cdot n^{n - 2}$。 参考代码： Code 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define LL long longconst int mod = 9999991;const int N = 1e6 + 5;LL n, fac[N] = &#123; 1 &#125;;LL qpow(LL base, LL power) &#123; LL res = 1LL; while(power) &#123; if(power &amp; 1) res = res * base % mod; base = base * base % mod; power &gt;&gt;= 1; &#125; return res;&#125;int main() &#123; scanf(\"%lld\", &amp;n); for(int i = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % mod; printf(\"%lld\", qpow(n, n - 2) * fac[n - 1] % mod); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"快速幂","slug":"快速幂","permalink":"https://leverimmy.top/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"计数","slug":"计数","permalink":"https://leverimmy.top/tags/%E8%AE%A1%E6%95%B0/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://leverimmy.top/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"【文化课】巧记等比数列求和公式","slug":"【文化课】巧记等比数列求和公式","date":"2020-03-18T02:08:10.000Z","updated":"2020-07-03T08:26:31.572Z","comments":true,"path":"2020/03/18/【文化课】巧记等比数列求和公式/","link":"","permalink":"https://leverimmy.top/2020/03/18/%E3%80%90%E6%96%87%E5%8C%96%E8%AF%BE%E3%80%91%E5%B7%A7%E8%AE%B0%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/","excerpt":"感觉 $S_n = \\dfrac{a_1 - q\\cdot a_n}{1 - q}(q\\neq 1)$ 这个公式实在是太愚蠢了， 于是自己整理了两个更漂亮的，也更容易记住的公式。","text":"感觉 $S_n = \\dfrac{a_1 - q\\cdot a_n}{1 - q}(q\\neq 1)$ 这个公式实在是太愚蠢了， 于是自己整理了两个更漂亮的，也更容易记住的公式。 $$\\boxed{S_n = a_n + \\dfrac{a_n - a_1}{q - 1}(q \\neq 1)}$$ 用斜率的概念来理解比较方便。 $$\\boxed{S_n = a_1\\cdot\\dfrac{q^n - 1}{q - 1}(q \\neq 1)}$$","categories":[{"name":"文化课","slug":"文化课","permalink":"https://leverimmy.top/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"数学","slug":"文化课/数学","permalink":"https://leverimmy.top/categories/%E6%96%87%E5%8C%96%E8%AF%BE/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://leverimmy.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"等比数列","slug":"等比数列","permalink":"https://leverimmy.top/tags/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97/"}]},{"title":"【游记】CSP-S2019 游记","slug":"【游记】CSP-S2019-游记","date":"2020-03-17T03:15:37.000Z","updated":"2020-07-03T08:11:38.080Z","comments":true,"path":"2020/03/17/【游记】CSP-S2019-游记/","link":"","permalink":"https://leverimmy.top/2020/03/17/%E3%80%90%E6%B8%B8%E8%AE%B0%E3%80%91CSP-S2019-%E6%B8%B8%E8%AE%B0/","excerpt":"CSP 已经过去四个月了，让我凭着仅存的记忆，书写下这段记忆吧。","text":"CSP 已经过去四个月了，让我凭着仅存的记忆，书写下这段记忆吧。 Day ?~-1终于停课了，在机房有一天没一天地打模拟赛，订正，打模拟赛…… 不过停课的这段时间倒是挺愉快的，每天早上吃完早饭可以直接去机房打代码，中午能有 early lunch。 更重要的是，下午能摆脱 17:30 的束缚，舒舒服服地洗一个澡。 Day 0最后一天当然是颓了。 尝试着把所有会的在洛谷上有“模板”标签的题都打了一遍，LCA 差点写挂，逆元忘记怎么推？这要退役啊。 然后就开始 CS1.6 了。 中途 mj 还来慰问了一下全机房，（你们要去全部一等奖啊）吓得大家都一惊。 中午睡了一觉，下午继续打板子，晚上就到叔叔家去了。 退 役 预 定。 Day 1早上吃了一碗面，没喝牛奶，肚子有点疼（这是要退役的节奏吧） 起得比较早，于是 07:05 就到了华科，没有什么人；不过一会儿同学们都陆陆续续地来了，抽签进了考场。 T1 （格雷码是啥？不会怎么办） 乱搞了一下，发现答案树和 01Trie 有些关系，开始猛地找规律。 最后发现逆推出答案的每一位就好了，此时大概 09:12，测了极限情况，没有问题。 T2感觉还可以做，推了一下树是一条链（也就是一个序列）上的情况 （飞速过大样例） 然后感觉可以把一棵树拆成很多条链，分别用序列搞，但是不同链上的贡献不会统计啊（（（（。 第二个样例 WA 了，调试的时候 RE 了（并不知道为什么 （第三个样例也太水了吧） 早知道就打 $O(n^3)$ 的暴力了。 T3感觉不可做，打了 10pts 的暴力就滚了，然而最后还是没拿分。 然后继续看 T2，越看越觉得自己的链写挂了，然后调了半天，最后就交卷了。 出考场，全世界都100 + 100 + 10 = 210。 似乎全世界 T2 都过了，T3 也都拿了10pts。 自己真的省一无缘了吧 晚上测了下洛谷和牛客的数据，感觉自己 Day 1 也就 100 多分吧。 退 役 预 定。 Day 2本来还想上 350 的，但现在看来没啥希望了。 昨天的心情不好一直持续到了今天。 T1, T2 都是 dp，T3 是一个树上问题。 然后完全没有掌握 dp 的我只会搜索，然后写了 T1, T2 的暴力。 然后发现 T3 的 $n^2$ 很好写，写了 40pts 的部分分；再加上链的部分分。 然后就不知道怎么办了。 最后 45min 发现 T2 可以剪枝，然后剪挂了； 最后 15min 发现 T3 的链写挂了，然后没改。 就这么结束了。 Day inf哦出成绩了。 本来水平就不咋地，然后成为了 HB 提高 1= 倒数第二名。","categories":[{"name":"杂笔","slug":"杂笔","permalink":"https://leverimmy.top/categories/%E6%9D%82%E7%AC%94/"},{"name":"游记","slug":"杂笔/游记","permalink":"https://leverimmy.top/categories/%E6%9D%82%E7%AC%94/%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"CSP2019S","slug":"CSP2019S","permalink":"https://leverimmy.top/tags/CSP2019S/"}]},{"title":"LaTeX 索引","slug":"【备忘录】LaTeX-索引","date":"2020-03-16T03:50:44.000Z","updated":"2020-07-03T08:04:30.185Z","comments":true,"path":"2020/03/16/【备忘录】LaTeX-索引/","link":"","permalink":"https://leverimmy.top/2020/03/16/%E3%80%90%E5%A4%87%E5%BF%98%E5%BD%95%E3%80%91LaTeX-%E7%B4%A2%E5%BC%95/","excerpt":"这个是 $\\LaTeX$ 的索引，可使用 Ctrl + F 进行查询中文关键词。","text":"这个是 $\\LaTeX$ 的索引，可使用 Ctrl + F 进行查询中文关键词。 逻辑非，非，not $\\neg$ \\neg 数码，digit，上划线，overline $\\overline{abc}$ \\overline{} 逻辑或，或，or $\\vee$，$\\bigvee$ \\vee, \\bigvee 逻辑与，与，and $\\wedge$，$\\bigwedge$ \\wedge, \\bigwedge 不存在，not exist $\\nexists$ \\nexists 圆，circle $\\odot$，$\\bigodot$ \\odot, \\bigodot 不同余 $ax\\not\\equiv1\\pmod{p}$ \\not\\equiv 全等，congruent $\\cong$ \\cong 赋值，def $:=$ := 真子集 $\\subsetneqq$，$\\supsetneqq$ \\subsetneqq, \\supsetneqq 非子集 $\\nsubseteq$，$\\nsupseteq$ \\nsubseteq, \\nsupseteq 子集，subset $\\subseteq$，$\\supseteq$ \\subseteq, \\supseteq 自交 $\\otimes$，$\\bigotimes$ \\otimes, \\bigotimes 异或，xor $\\oplus$，$\\bigoplus$ \\oplus, \\bigoplus 除号，除，除以 $\\div$ \\div 乘除号，乘除 $\\divideontimes$ \\divideontimes 负正号，减加，负正 $\\mp$ \\mp 正负号，加减，正负 $\\pm$ \\pm 整除，约数 $a|b$ | 不整除 $a \\nmid b$ \\nmid 取模，模运算，模 $a % b$，$a \\mod b$，$a \\equiv1\\pmod{b}$ \\%, \\mod, \\pmod{} 最大公约数，gcd $\\gcd(a, b)$ \\gcd 最小公倍数，lcm $\\operatorname{lcm}(a, b)$ \\operatorname{lcm} 补集，C $\\complement_{U}A$，$\\bar{A}$，$\\overline{A}$ \\complement_{}, \\bar{}, \\overline{} 无穷，正无穷，负无穷，无限大 $\\infty$ \\infty 最小值，min，minimum，较小的 $\\min(a, b)$ \\min 最大值，max，maximum，较大的 $\\max(a, b)$ \\max 余切，cotangent，cot $\\cot\\theta$ \\cot 指数函数，指数，exponent $\\exp_a b = a^b$ \\exp_{} 正割，secant，sec $\\sec\\alpha$ \\sec 余割，cosecant，csc $\\csc\\beta$ \\csc 相似，similar，sim $\\sim$ \\sim 勾，对，是的，正确，完成，tick，correct $\\checkmark$ \\checkmark 同余 $\\equiv$ \\equiv LaTeX，拉泰赫 $\\LaTeX$ \\latex 斜着的点，斜点 $\\ddots$ \\ddots 竖着的点，竖点 $\\vdots$ \\vdots 组合 $\\dbinom{n}{m}$，$\\binom{n}{m}$，$\\tbinom{n}{m}$ \\dbinom{}{}, \\binom{}{}, \\tbinom{}{} 求和，连加，西格玛，sum $\\sum_{j = 1}^{10}a_j$ \\sum_{}^{} 求积，连乘，product，派 $\\prod_{j = 1}^{10}a_j$ \\prod_{}^{} 分数，fraction $\\dfrac{1}{2}$，$\\frac{1}{2}$，$\\tfrac{1}{2}$ \\dfrac{}{}, \\frac{}{}, \\tfrac{}{} alpha，阿尔法 $\\alpha$ \\alpha beta，贝塔 $\\beta$ \\beta Delta，德尔塔，变化量 $\\Delta$ \\Delta 三角形，triangle $\\triangle$ \\triangle 向量 $\\vec{AB}$，$\\overrightarrow{AB}$，$\\mathbf{e}$ \\vec{}, \\overrightarrow{} \\mathbf{} 数集，实数集，整数集，自然数集，有理数集，复数集，R，Z，N，Q，C $\\mathbb{R}$，$\\mathbb{Z}$，$\\mathbb{N}$，$\\mathbb{Q}$，$\\mathbb{C}$ \\mathbb{R}, \\mathbb{Z}, \\mathbb{N}, \\mathbb{Q}, \\mathbb{C} 根号，sqrt，root $\\sqrt[3]{2}$ \\sqrt[]{} 次幂，次方，方，power，上标 $a^{2}$ ^ 下标，序号，index $a_i$ _ theta，西塔 $\\theta$ \\theta 角，角度，triangle $\\angle AOB$ \\angle 正弦，sin，sine $\\sin\\theta$ \\sin 余弦，cos，cosine $\\cos\\varphi$ \\cos 绝对值，absolute value $\\left|-1\\right|$ \\left| \\right| tangent，正切，tan $\\tan\\alpha$ \\tan\\alpha 夹角，向量的夹角 $&lt;\\mathbf{a}, \\mathbf{b}&gt;$，$\\left&lt;\\mathbf{a}, \\mathbf{b}\\right&gt;$ &lt; &gt; \\left&lt; \\right&gt; 下取整，floor $\\lfloor \\dfrac{1}{2} \\rfloor$，$\\left\\lfloor \\dfrac{1}{2} \\right\\rfloor$ \\lfloor \\rfloor \\left\\lfloor \\right\\rfloor 上取整，ceil，ceiling $\\lceil \\dfrac{1}{2}\\rceil$，$\\left\\lceil \\dfrac{1}{2}\\right\\rceil$ \\lceil \\rceil \\left\\lceil \\right\\rceil 派，pi，圆周率 $\\pi$ \\pi fai，phi $\\phi$，$\\varphi$ \\phi, \\varphi 空集，empty $\\emptyset$，$\\varnothing$ \\emptyset \\varnothing 左右，放大，left，right $\\left|-\\dfrac{1}{2}\\right|$ \\left \\right mu，miu，莫比乌斯 $\\mu$ \\mu 大于等于，不小于 $\\ge$，$\\geqslant$ \\ge, \\geqslant 小于等于，不大于 $\\le$，$\\leqslant$ \\le, \\leqslant 不等于 $\\neq$ \\neq 约等于，约，近似 $\\approx$ \\approx 远大于 $\\gg$ \\gg 远小于 $\\ll$ \\ll 平行, parallel $\\parallel$ \\parallel 垂直，互质 $\\perp$ \\perp 点乘，times，multiply，数量积，内积 $\\cdot$ \\cdot 叉乘，times，multiply，向量积，外积 $\\times$ \\times 省略号，横着的点，横点 $\\cdots$，$\\ldots$ \\cdots, \\ldots 上箭头，向上，up arrow $\\uparrow$，$\\Uparrow$，$\\upharpoonleft$，$\\upharpoonright$，$\\upuparrows$ \\uparrow, \\Uparrow, \\upharpoonleft, \\upharpoonright, \\upuparrows 下箭头，向下，down arrow $\\downarrow$，$\\Downarrow$，$\\downharpoonleft$，$\\downharpoonright$，$\\downdownarrows$ \\downarrow, \\Downarrow, \\downharpoonleft, \\downharpoonright, \\downdownarrows 度，分类讨论 $1^{\\circ}$ \\circ 因为，because $\\because$ \\because 所以，therefore $\\therefore$ \\therefore 对于所有，全称量词，forall $\\forall$ \\forall 存在量词，存在，exist $\\exists$ \\exists 否，否定，不，neg $\\neg$ \\neg 弧，arc $\\overset{\\frown}{AB}$ \\overset{\\frown} 交集，交 $\\cap$，$\\bigcap$ \\cap, \\bigcap 并集，并 $\\cup$，$\\bigcup$ \\cup, \\bigcup 矩阵，matrix $\\begin{bmatrix}1 &amp; 1 \\\\ 1 &amp; 0\\end{bmatrix}$ \\begin{bmatrix} \\end{bmatrix} 条件，cases，分段函数，方程组，不等式组 $f(x) = \\begin{cases}1 &amp; x \\in \\mathbb{Q} \\\\ 0 &amp; x \\notin \\mathbb{Q}\\end{cases}$ \\begin{cases} \\end{cases} 属于 $\\in, \\ni$ \\in, \\ni 不属于 $\\notin, \\not\\ni$ \\notin, \\not\\ni 文本，正体 $\\text{otherwise}$ \\text{} 欧米伽，omega $\\omega$ \\omega 下划线 $\\underline{ABC}$ \\underline{} 加热，heat $\\triangleq$ \\triangleq 上括号 $\\overbrace{1+2+\\cdots+100}$ \\overbrace{} 积分 $\\int_{0}^{1}e^x\\text{d}x$ \\int_{}^{} 对齐 $\\begin{aligned}f(x) &amp; = (x + 1)^2 \\\\ &amp; = x^2 + 2x + 1\\end{aligned}$ \\begin{aligned}\\end{aligned} 双重积分 $\\iint_{S}^{T}\\text{d}x\\text{d}y$ \\iint_{}^{} 三重积分 $\\iiint_{S}^{T}\\text{d}x\\text{d}y\\text{d}z$ \\iiint_{}^{} 曲面积分 $\\oint_{C}x^3\\text{d}x$ \\oint_{} 极限，limit $\\lim_{n\\to\\infty}x_n$，$\\lim\\limits_{n\\to\\infty}x_n$ \\lim_{}, \\lim\\limits_{} 下括号 $\\underbrace{1+2+\\cdots+100}$ \\underbrace{}","categories":[{"name":"杂笔","slug":"杂笔","permalink":"https://leverimmy.top/categories/%E6%9D%82%E7%AC%94/"},{"name":"备忘录","slug":"杂笔/备忘录","permalink":"https://leverimmy.top/categories/%E6%9D%82%E7%AC%94/%E5%A4%87%E5%BF%98%E5%BD%95/"}],"tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"https://leverimmy.top/tags/LaTeX/"}]},{"title":"【学习笔记】DLX 学习笔记","slug":"【学习笔记】DLX-学习笔记","date":"2020-03-16T02:39:11.000Z","updated":"2020-07-03T08:18:54.435Z","comments":true,"path":"2020/03/16/【学习笔记】DLX-学习笔记/","link":"","permalink":"https://leverimmy.top/2020/03/16/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91DLX-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"DLX 指使用 Dancing Links 优化后的 X 算法，在随机情况下能极快速地解决精确覆盖问题。","text":"DLX 指使用 Dancing Links 优化后的 X 算法，在随机情况下能极快速地解决精确覆盖问题。 问题引入 就在刚才，你的同学终于写完了 P4205 『NOI2005』智慧珠游戏，并向你展示了他的 500+ 行的代码。 小时候，你玩智慧珠；长大后，智慧珠玩你，你准备怎么办？ 就在刚才，你的同学码力全开写完了 P1784 数独，感觉有了暴力搜索，他就能 AK 学生会组织的所有数独比赛。 面对数独，你不愿去打那恼人的暴力，你又准备怎么办？ 精确覆盖问题 定义： 精确覆盖问题 (Exact Cover Problem) 是指给定许多集合 $S_i (1 \\le i \\le n)$ 以及一个集合 $X$，求满足以下条件的无序多元组 $(T_1, T_2, \\cdots , T_m)$： (1) $\\forall i, j \\in [1, m],T_i\\bigcap T_j = \\varnothing (i \\neq j)$ (2) $X = \\bigcup\\limits_{i = 1}^{m}T_i$ (3) $\\forall i \\in[1, m], T_i \\in {S_1, S_2, \\cdots, S_n}$ 例如，若给出 $$\\begin{aligned} &amp; S_1 = {5, 9, 17} \\\\ &amp; S_2 = {1, 8, 119} \\\\ &amp; S_3 = {3, 5, 17} \\\\ &amp; S_4 = {1, 8} \\\\ &amp; S_5 = {3, 119} \\\\ &amp; S_6 = {8, 9, 119} \\\\ &amp; X = {1, 3, 5, 8, 9, 17, 119}\\end{aligned}$$ 则 $(S_1, S_4, S_5)$ 为一组合法解。 问题转化 我们将 $\\bigcup\\limits_{i = 1}^{n}S_i$ 中的所有数离散化，那么可以得到这么一个模型： 给定一个 01 矩阵，你可以选择一些行，使得最终每列都恰好有一个 1。 举个例子，我们对 (2.1) 中的例子进行建模，可以得到这么一个矩阵： $$\\begin{pmatrix} 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1\\end{pmatrix}$$ 其中第 $i$ 行表示着 $S_i$，而这一行的每个数依次表示 $[1 \\in S_i],[3 \\in S_i],[5 \\in S_i],\\cdots,[119 \\in S_i]$。 第一个不优秀的做法： 我们可以枚举选择哪些行，最后检查这个方案是否合法。 因为每一行都有选或者不选两种状态，所以枚举行的时间复杂度是 $O(2^n)$ 的； 而每次检查都需要 $O(nm)$ 的时间复杂度。所以总的复杂度是 $O(nm\\cdot2^n)$。 Code 123456789101112131415161718192021int ok = 0;for(int state = 0; state &lt; 1 &lt;&lt; n; ++state) &#123; // 枚举每行是否被选 for(int i = 1; i &lt;= n; ++i) if((1 &lt;&lt; i - 1) &amp; state) for(int j = 1; j &lt;= m; ++j) a[i][j] = 1; int flag = 1; for(int j = 1; j &lt;= m; ++j) for(int i = 1, bo = 0; i &lt;= n; ++i) if(a[i][j]) &#123; if(bo) flag = 0; else bo = 1; &#125; if(!flag) continue; else &#123; ok = 1; for(int i = 1; i &lt;= n; ++i) if((1 &lt;&lt; i - 1) &amp; state) printf(\"%d \", i); puts(\"\"); &#125; memset(a, 0, sizeof(a));&#125;if(!ok) puts(\"No solution.\"); 第二个不那么优秀的做法： 考虑到 01 矩阵的特殊性质，我们可以把每一行都看做成一个 $m$ 位二进制数。 因此被转化为了 给你 $n$ 个 $m$ 位二进制数，要求选择一些数，使得任意两个数的与都为0，且所有数的或为 $2^m - 1$。 tmp 表示的是截至目前的所有被选择了的 $m$ 位二进制数的或。 因为每一行都有选或者不选两种状态，所以枚举行的时间复杂度是 $O(2^n)$ 的； 而每次计算 tmp 都需要 $O(n)$ 的时间复杂度。所以总的复杂度是 $O(n\\cdot2^n)$。 Code 123456789101112131415161718int ok = 0;for(int i = 1; i &lt;= n; ++i) for(int j = m; j &gt;= 1; --j) num[i] = num[i] &lt;&lt; 1 | a[i][j];for(int state = 0; state &lt; 1 &lt;&lt; n; ++state) &#123; int tmp = 0; for(int i = 1; i &lt;= n; ++i) if((1 &lt;&lt; i - 1) &amp; state) &#123; if(tmp &amp; num[i]) break; tmp |= num[i]; &#125; if(tmp == (1 &lt;&lt; m) - 1) &#123; ok = 1; for(int i = 1; i &lt;= n; ++i) if((1 &lt;&lt; i - 1) &amp; state) printf(\"%d \", i); puts(\"\"); &#125;&#125;if(!ok) puts(\"No solution.\"); X 算法刚才的暴力实在是太菜了！连 $1 \\le n,m \\le 200$ 都跑不过…… Donald E. Knuth 提出了一个叫做 X 算法 (Algorithm X) 的东西，其思想与刚才的暴力差不多，但是方便优化。 继续以 (2.1) 中提到的例子为载体，我们得到的是一个这样的 01 矩阵： $$\\begin{pmatrix} 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1\\end{pmatrix}$$ 此时第一行有 $3$ 个 $1$，第二行有 $3$ 个 $1$，第三行有 $3$ 个 $1$，第四行有 $2$ 个 $1$，第五行有 $2$ 个 $1$，第六行有 $3$ 个 $1$。选择第一行，将它删除，并将所有 $1$ 所在的列打上标记； $$ \\begin{pmatrix} \\color{Blue}0 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}1 &amp; \\color{Blue}0 \\\\ 1 &amp; 0 &amp; \\color{Red}0 &amp; 1 &amp; \\color{Red}0 &amp; \\color{Red}0 &amp; 1 \\\\ 0 &amp; 1 &amp; \\color{Red}1 &amp; 0 &amp; \\color{Red}0 &amp; \\color{Red}1 &amp; 0 \\\\ 1 &amp; 0 &amp; \\color{Red}0 &amp; 1 &amp; \\color{Red}0 &amp; \\color{Red}0 &amp; 0 \\\\ 0 &amp; 1 &amp; \\color{Red}0 &amp; 0 &amp; \\color{Red}0 &amp; \\color{Red}0 &amp; 1 \\\\ 0 &amp; 0 &amp; \\color{Red}0 &amp; 1 &amp; \\color{Red}1 &amp; \\color{Red}0 &amp; 1 \\end{pmatrix} $$ 选择所有被标记的列，将它们删除，并将这些列中含 $1$ 的行打上标记； $$ \\begin{pmatrix} \\color{Blue}0 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}1 &amp; \\color{Blue}0 \\\\ 1 &amp; 0 &amp; \\color{Blue}0 &amp; 1 &amp; \\color{Blue}0 &amp; \\color{Blue}0 &amp; 1 \\\\ \\color{Red}0 &amp; \\color{Red}1 &amp; \\color{Blue}1 &amp; \\color{Red}0 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Red}0 \\\\ 1 &amp; 0 &amp; \\color{Blue}0 &amp; 1 &amp; \\color{Blue}0 &amp; \\color{Blue}0 &amp; 0 \\\\ 0 &amp; 1 &amp; \\color{Blue}0 &amp; 0 &amp; \\color{Blue}0 &amp; \\color{Blue}0 &amp; 1 \\\\ \\color{Red}0 &amp; \\color{Red}0 &amp; \\color{Blue}0 &amp; \\color{Red}1 &amp; \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Red}1 \\end{pmatrix} $$ 选择所有被标记的行，将它们删除； $$ \\begin{pmatrix} \\color{Blue}0 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}1 &amp; \\color{Blue}0 \\\\ 1 &amp; 0 &amp; \\color{Blue}0 &amp; 1 &amp; \\color{Blue}0 &amp; \\color{Blue}0 &amp; 1 \\\\ \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}0 \\\\ 1 &amp; 0 &amp; \\color{Blue}0 &amp; 1 &amp; \\color{Blue}0 &amp; \\color{Blue}0 &amp; 0 \\\\ 0 &amp; 1 &amp; \\color{Blue}0 &amp; 0 &amp; \\color{Blue}0 &amp; \\color{Blue}0 &amp; 1 \\\\ \\color{Blue}0 &amp; \\color{Blue}0 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 \\end{pmatrix} $$ 这表示表示我们选择了一行，且这一行的所有 $1$ 所在的列不能有其他 $1$ 了。 于是我们得到了这样的一个新的小 01 矩阵：$$\\begin{pmatrix} 1 &amp; 0 &amp; 1 &amp; 1 \\\\ 1 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 1\\end{pmatrix}$$ 此时第一行（原来的第二行）有 $3$ 个 $1$，第二行（原来的第四行）有 $2$ 个 $1$，第三行（原来的第五行）有 $2$ 个 $1$。选择第一行（原来的第二行），将它删除，并将所有 $1$ 所在的列打上标记； $$ \\begin{pmatrix} \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}1 \\\\ \\color{Red}1 &amp; 0 &amp; \\color{Red}1 &amp; \\color{Red}0 \\\\ \\color{Red}0 &amp; 1 &amp; \\color{Red}0 &amp; \\color{Red}1 \\end{pmatrix} $$ 选择所有被标记的列，将它们删除，并将这些列中含 $1$ 的行打上标记； $$ \\begin{pmatrix} \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}1 \\\\ \\color{Blue}1 &amp; \\color{Red}0 &amp; \\color{Blue}1 &amp; \\color{Blue}0 \\\\ \\color{Blue}0 &amp; \\color{Red}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 \\end{pmatrix} $$ 选择所有被标记的行，将它们删除； $$ \\begin{pmatrix} \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}1 \\\\ \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}0 \\\\ \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 \\end{pmatrix} $$ 于是我们得到了一个空矩阵。但是上次删除的行 “1 0 1 1” 不是全 $1$ 的，说明选择有误； $$\\begin{pmatrix}\\end{pmatrix}$$ 回溯到步骤 $4$，我们考虑选择第二行（原来的第四行），将它删除，并将所有 $1$ 所在的列打上标记； $$ \\begin{pmatrix} \\color{Red}1 &amp; 0 &amp; \\color{Red}1 &amp; 1 \\\\ \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}0 \\\\ \\color{Red}0 &amp; 1 &amp; \\color{Red}0 &amp; 1 \\end{pmatrix} $$ 选择所有被标记的列，将它们删除，并将这些列中含 $1$ 的行打上标记； $$ \\begin{pmatrix} \\color{Blue}1 &amp; \\color{Red}0 &amp; \\color{Blue}1 &amp; \\color{Red}1 \\\\ \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}0 \\\\ \\color{Blue}0 &amp; 1 &amp; \\color{Blue}0 &amp; 1 \\end{pmatrix} $$ 选择所有被标记的行，将它们删除； $$ \\begin{pmatrix} \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}1 \\\\ \\color{Blue}1 &amp; \\color{Blue}0 &amp; \\color{Blue}1 &amp; \\color{Blue}0 \\\\ \\color{Blue}0 &amp; 1 &amp; \\color{Blue}0 &amp; 1 \\end{pmatrix} $$ 于是我们得到了这样的一个矩阵：$$\\begin{pmatrix} 1 &amp; 1\\end{pmatrix}$$ 此时第一行（原来的第五行）有 $2$ 个 $1$，将它们全部删除，我们得到了一个空矩阵：$$\\begin{pmatrix}\\end{pmatrix}$$ 上一次删除的时候，删除的是全 $1$ 的行，因此成功，算法结束。 答案即为我们删除的三行：$1, 4, 5$。 强烈建议自己模拟一遍矩阵删除、还原与回溯的过程后再接着阅读下文。 我们可以概括出 X 算法的过程： 对于现在的矩阵 $M$，选择并标记一列 $r$，将 $r$ 添加至 $S$ 中； 如果尝试了所有的 $r$ 却无解，则算法结束，输出无解。 标记与 $r$ 相关的行 $r_i$ 和 $c_i$； 删除所有标记的行和列，得到新矩阵 $M’$； 如果 $M’$ 为空，且 $r$ 为全 $1$ 的，则算法结束，输出被删除的行组成的集合 $S$； 如果 $M’$ 为空，且 $r$ 不为全 $1$ 的，则恢复与 $r$ 相关的行 $r_i$ 以及列 $c_i$，跳转至步骤 $1$； 如果 $M’$ 不为空，则跳转至步骤 $1$； 不难看出，X 算法需要大量的 “删除行”、“删除列” 和 “恢复行”、“恢复列” 的操作。 Donald E. Knuth 想到了用双向十字链表来维护这些操作。 而在双向十字链表上不断跳跃的过程被形象地比喻成“跳跃”，因此被用来优化 X 算法的双向十字链表也被称为 “Dancing Links”。 Dancing Links 优化的 X 算法 预编译命令 这句话太好用了 1#define IT(i, A, x) for(i = A[x]; i != x; i = A[i]) 定义 既然是双向十字链表，那么一定是有四个指针域的：一个指上方的元素，一个指下方的元素，一个指左边的元素，一个指右边的元素。而每个元素 $i$ 在整个双向十字链表系中都对应着一个格子，因此还要表示 $i$ 所在的列和所在的行。像这样： 是不是非常简单？ 而其实大型双向链表其实是长这样的： 每一行都有一个行首指示，每一列都有一个列指示。 行首指示为 first[]，列指示是我们虚拟出的 $c + 1$ 个结点。 同时，每一列都有一个 siz[] 表示这一列的元素个数。 特殊地，$0$ 号结点无右结点等价于这个 Dancing Links 为空。 1234static const int MS = 1e5 + 10;int n, m, idx, first[MS + 10], siz[MS + 10];int L[MS + 10], R[MS + 10], U[MS + 10], D[MS + 10];int col[MS + 10], row[MS + 10]; $\\text{remove(c)}$ 操作 $\\text{remove(c)}$ 表示在 Dancing Links 中删除第 $c$ 列以及与其相关的行和列。 我们先将 $c$ 删除，此时： (1) $c$ 左侧的结点的右结点应为 $c$ 的右结点； (2) $c$ 右侧的结点的左结点应为 $c$ 的左结点。 即 L[R[c]] = L[c], R[L[c]] = R[c];。 然后我们要顺着这一列往下走，把走过的每一行都删掉。 如何删掉每一行呢？枚举当前行的指针 $j$，此时： (1) $j$ 上方的结点的下结点应为 $j$ 的下结点； (2) $j$ 下方的结点的上结点应为 $j$ 的上结点。 注意要修改每一列的元素个数。 即 U[D[j]] = U[j], D[U[j]] = D[j], --siz[col[j]];。 因此 $\\text{remove(c)}$ 的代码实现就非常简单了： 其中第一个 IT(i, D, c) 等价于 for(i = D[c]; i != c; i = D[i])，即在顺着这一列从上往下遍历； 第二个 IT(j, R, i) 等价于 for(j = R[i]; j != i; j = R[j])，即在顺着这一行从左往右遍历。 123456void remove(const int &amp;c) &#123; int i, j; L[R[c]] = L[c], R[L[c]] = R[c]; IT(i, D, c) IT(j, R, i) U[D[j]] = U[j], D[U[j]] = D[j], --siz[col[j]];&#125; $\\text{recover(c)}$ 操作 $\\text{recover(c)}$ 表示在 Dancing Links 中还原第 $c$ 列以及与其相关的行和列。 $\\text{recover(c)}$ 即 $\\text{remove(c)}$ 的逆操作，在这里就不多赘述了。 值得注意的是， $\\text{recover(c)}$ 的所有操作的顺序与 $\\text{remove(c)}$ 的操作恰好相反。 在这里给出 $\\text{recover(c)}$ 的代码实现： 123456void recover(const int &amp;c) &#123; int i, j; IT(i, U, c) IT(j, L, i) U[D[j]] = D[U[j]] = j, ++siz[col[j]]; L[R[c]] = R[L[c]] = c;&#125; $\\text{build(r, c)}$ 操作 $\\text{build(r, c)}$ 表示新建一个大小为 $r \\times c$，即有 $r$ 行，$c$ 列的 Dancing Links。 我们新建 $c + 1$ 个结点，为列指示。 第 $i$ 个点的左结点为 $i - 1$，右结点为 $i + 1$，上结点为 $i$，下结点为 $i$。 特殊地， $0$ 结点的左结点为 $c$，$c$ 结点的右结点为 $0$。 于是我们得到了一条链： 12345678910void build(const int &amp;r, const int &amp;c) &#123; n = r, m = c; for(int i = 0; i &lt;= c; ++i) &#123; L[i] = i - 1, R[i] = i + 1; U[i] = D[i] = i; &#125; L[0] = c, R[c] = 0, idx = c; memset(first, 0, sizeof(first)); memset(siz, 0, sizeof(siz));&#125; 这样就初始化了一个 Dancing Links。 $\\text{insert(r, c)}$ 操作 $\\text{insert(r, c)}$ 表示在第 $r$ 行，第 $c$ 列插入一个结点。 我们分两种情况来操作： (1) 如果第 $r$ 行没有元素，那么直接插入一个元素，并使 $first(r)$ 指向这个元素； (2) 如果第 $r$ 行有元素，那么将这个新元素 用一种奇异的方式 与 $c$ 和 $first(r)$ 连接起来。 对于 (1)，我们可以通过 first[r] = L[idx] = R[idx] = idx; 来实现； 对于 (2)，（我们称这个新元素为 $idx$）： 我们把 $idx$ 插入到 $c$ 的正下方，此时： (1) $idx$ 下方的结点为原来 $c$ 的下结点； (2) $idx$ 下方的结点（即原来 $c$ 的下结点）的上结点为 $idx$; (3) $idx$ 的上结点为 $c$； (4) $c$ 的下结点为 $idx$。 注意记录 $idx$ 的所在列和所在行，以及更新这一列的元素个数。 12col[++idx] = c, row[idx] = r, ++siz[c];U[idx] = c, D[idx] = D[c], U[D[c]] = idx, D[c] = idx; 强烈建议读者完全掌握这几步的顺序后再继续阅读本文。 我们把 $idx$ 插入到 $first(r)$ 的正右方，此时： (1) $idx$ 右侧的结点为原来 $first(r)$ 的右结点； (2) 原来 $first(r)$ 右侧的结点的左结点为 $idx$； (3) $idx$ 的左结点为 $first(r)$； (4) $first(r)$ 的右结点为 $idx$。 12L[idx] = first[r], R[idx] = R[first[r]];R[first[r]] = idx, L[R[first[r]]] = idx; 强烈建议读者完全掌握这几步的顺序后再继续阅读本文。 对于 $\\text{insert(r, c)}$ 这个操作，我们可以画图来辅助理解： 留心曲线箭头的方向。 在这里给出 $\\text{insert(r, c)}$ 的代码： 123456789void insert(const int &amp;r, const int &amp;c) &#123; row[++idx] = r, col[idx] = c, ++siz[c]; U[idx] = D[idx] = c, U[D[c]] = idx, D[c] = idx; if(!first[r]) first[r] = L[idx] = R[idx] = idx; else &#123; L[idx] = first[r], R[idx] = R[first[r]]; L[R[first[r]]] = idx, R[first[r]] = idx; &#125;&#125; $\\text{dance()}$ 操作 $\\text{dance()}$ 即为递归地删除以及还原各个行列的过程。 (1) 如果 $0$ 号结点没有右结点，那么矩阵为空，记录答案并返回； (2) 选择列元素个数最少的一列，并删掉这一列； (3) 遍历这一列所有有 $1$ 的行，枚举它是否被选择； (4) 递归调用 $\\text{dance()}$，如果可行，则返回；如果不可行，则恢复被选择的行； (5) 如果无解，则返回； 在这里给出 $\\text{dance()}$ 的代码实现： 12345678910111213141516bool dance(int dep) &#123; int i, j, c = R[0]; if(!R[0]) &#123; ans = dep; return 1; &#125; IT(i, R, 0) if(siz[i] &lt; siz[c]) c = i; remove(c); IT(i, D, c) &#123; stk[dep] = row[i]; IT(j, R, i) remove(col[j]); if(dance(dep + 1)) return 1; IT(j, L, i) recover(col[j]); &#125; recover(c); return 0;&#125; 其中 stk[] 用来记录答案。 注意我们每次优先选择列元素个数最少的一列进行删除，这样能保证程序具有一定的启发性（乱扯的），是搜索树分支最少（不会证）。 时间复杂度分 (luàn) 析 (chě)DLX 的时间复杂度是 指数级 的，它递归及回溯的次数与矩阵中 $1$ 的个数有关，与矩阵的 $r, c$ 等参数无关。 因此理论复杂度大概在 $O(c^n)$ 左右，其中 $c$ 为某个非常接近于 $1$ 的常数，$n$ 为矩阵中 $1$ 的个数。 但实际情况下 DLX 表现良好，一般能解决大部分的问题。 ###如何建模 DLX 的难点，除了垃圾链表连这连那就是建模。 请确保已经完全掌握 DLX 模板后再继续阅读本文。 我们每拿到一个题，应该考虑行和列所表示的意义： 行表示 决策，因为每行对应着一个集合，也就对应着选 / 不选； 列表示 状态，因为第 $i$ 列对应着某个条件 $P_i$。 对于某一行而言，由于不同的列的值不尽相同，我们 由不同的状态，定义了一个决策。 【洛谷】 P1784 数独 题目链接 解析 先考虑决策是什么。在这一题中，每一个决策可以用形如 $(r, c, w)$ 的有序三元组表示。注意到 “宫” 并不是决策的参数，因为它 可以被每个确定的 $(r, c)$ 表示。因此有 $9 \\times 9 \\times 9 = 729$ 行。再考虑状态是什么。我们思考一下 $(r, c, w)$ 这个决将会造成什么影响。记 $(r, c)$ 所在的宫为 $b$。(1) 第 $r$ 行用了一个 $w$（用 $9 \\times 9 = 81$ 列表示）；(2) 第 $c$ 列用了一个 $w$（用 $9 \\times 9 = 81$ 列表示）；(3) 第 $b$ 宫用了一个 $w$（用 $9 \\times 9 = 81$ 列表示）；(4) $(r, c)$ 中填入了一个数（用 $9 \\times 9 = 81$ 列表示）。因此有 $81 \\times 4 = 324$ 列，共 $729 \\times 4 = 2916$ 个 $1$。至此，我们成功地将 $9 \\times 9$ 的数独问题转化成了一个有 $729$ 行，$324$ 列，共 $2916$ 个 $1$ 的精确覆盖问题。 【洛谷】 P1074 靶形数独 题目链接 解析 这一题与 (5.1) 的模型构建 一模一样，主要区别在于答案的更新。这一题可以开一个权值数组，每次找到一组数独的解时，每个位置上的数乘上对应的权值计入答案即可。 【洛谷】 P4205 『NOI2005』智慧珠游戏 题目链接 解析 终于，我们打到了大 boss。定义：题中给我们的智慧珠的形态，称为这个智慧珠的 标准形态。显然，我们可以通过改变两个参数 $d$（表示顺时针旋转 $90^{\\circ}$ 的次数）和 $f$（是否水平翻转）来改变这个智慧珠的形态。仍然，我们先考虑决策是什么。在这一题中，每一个决策可以用形如 $(v, d, f, i)$ 的有序五元组表示。表示第 $i$ 个智慧珠的 标准形态 的左上角的位置，序号为 $v$，经过了 $d$ 次顺时针转 $90^{\\circ}$。巧合的是，我们可以令 $f = 1$ 时不水平翻转，$f = -1$ 时水平翻转，从而达到简化代码的目的。因此有 $55 \\times 4 \\times 2 \\times 12 = 5280$ 行。需要注意的是，因为一些不合法的填充，如 $(1, 0, 1, 4)$，所以在实际操作中，空的智慧珠棋盘也只需要建出 $2730$ 行。再考虑状态是什么。这一题的状态比较简单。我们思考一下，$(v, d, f, i)$ 这个决策会造成什么影响。(1) 某些格子被占了（用 $55$ 列表示）；(2) 第 $i$ 个智慧珠被用了（用 $12$ 列表示）。因此有 $55 + 12 = 67$ 列，共 $5280 \\times (5 + 1) = 31680$ 个 $1$。至此，我们成功地将智慧珠游戏转化成了一个有 $5280$ 行，$67$ 列，共 $31680$ 个 $1$ 的精确覆盖问题。 练习 SP1110 SUDOKU - Sudoku 题目链接 『kuangbin带你飞』专题三 Dancing Links 题表链接 总结DLX 能用来解决精确覆盖问题，而适当地建立起模型后能解决一些毒瘤的大模拟。 参考资料 [1]英雄哪里出来 的 《夜深人静写算法（九）- Dancing Links X（跳舞链）》 [2]万仓一黍 的 《跳跃的舞者，舞蹈链（Dancing Links）算法——求解精确覆盖问题》 [3]zhangjianjunab 的 《DLX 算法一览》 [4]静听风吟。的 《搜索：DLX 算法》 [5]刘汝佳，陈锋 的 《算法竞赛入门经典：训练指南》","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"杂项","slug":"学习笔记/杂项","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"DLX","slug":"DLX","permalink":"https://leverimmy.top/tags/DLX/"},{"name":"搜索","slug":"搜索","permalink":"https://leverimmy.top/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"【游记】记游 8102 PION","slug":"【游记】记游-8102-PION","date":"2018-11-25T04:18:21.000Z","updated":"2020-07-03T08:23:08.920Z","comments":true,"path":"2018/11/25/【游记】记游-8102-PION/","link":"","permalink":"https://leverimmy.top/2018/11/25/%E3%80%90%E6%B8%B8%E8%AE%B0%E3%80%91%E8%AE%B0%E6%B8%B8-8102-PION/","excerpt":"就在两周之前，差不多这个时间段，人生中的第一次$NOIP$结束了。 这一次纵然有许多遗憾，也让我获取到了许多经验。","text":"就在两周之前，差不多这个时间段，人生中的第一次$NOIP$结束了。 这一次纵然有许多遗憾，也让我获取到了许多经验。 Day -3屋漏偏逢连夜雨，学校的期中考试竟然在$11.8-11.9$号举行，而$10$号就要$NOIP$了啊！ Day 0在叔叔家复习了模拟、搜索等基本内容。刷了$3$道水题。 Day 1T1 铺设道路我并不知道这是一道原题，因此我打了一个暴力搜索，小样例过了，大样例T了，慌得一批的我出了几组小的数据，过了，然后就没管这一题了。 我发现搜索的基本功很有用，毕竟它能使你暴力弄点分回来。 知道它是原题的我被震惊到了，立志下次NOIP之前要把以前的题都做一遍 我做题的思路大概是这样的：先遍历一遍，如果有地方是零，就左右分别递归 并不知道记录是否为0的book数组的优化是否有用…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;using namespace std;int n,cnt,minn=99999;int d[100010],book[100010];void search(int l,int r)&#123; if(l&gt;=r) &#123; cnt+=d[l]; d[l]=0; return; &#125; int flag=1; for(int i=l;i&lt;=r;i++) if(d[i]==0) &#123; flag=0; book[i]=1; int left=i-1,right=i+1; for(int j=i-1;j&gt;=l;j--) if(book[j]==1) left=j; search(l,left);//左右分别递归 for(int j=i+1;j&lt;=r;j++) if(book[j]==1) right=j; search(right,r);//左右分别递归 &#125; if(flag==1) &#123; cnt++; for(int i=l;i&lt;=r;i++) d[i]--; search(l,r); &#125;&#125;int main()&#123; //freopen(\"road.in\",\"r\",stdin); //freopen(\"road.out\",\"w\",stdout); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;d[i]); minn=minn&gt;d[i]?d[i]:minn; &#125; for(int i=1;i&lt;=n;i++) d[i]-=minn;//先处理一遍 cnt+=minn; search(1,n); printf(\"%d\",cnt); return 0;&#125; T2 货币系统并不会做这道题，所以就只准备拿前6个测试点的分（可是只得了15分？？？）（肯定有个地方出锅了） 话说 1namespace point_x&#123; &#125; 很好用，这让我的代码可读性很高，很容易调试 T3 赛道修建然而还是不会做 分了namespace的我还是只得了5分 （肯定又有哪里出锅了） 原因暂未查明 普及组T1 标题统计这题甚是奇怪，在我的记忆中……NOIP普及组可是不曾考过字符串的啊 想都没想，5分钟就肝了这道题 考试源代码： 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;string s;int len;int main()&#123; //freopen(\"title.in\",\"r\",stdin); //freopen(\"title.out\",\"w\",stdout); while(cin&gt;&gt;s) len+=s.length(); cout&lt;&lt;len; return 0;&#125; T2 龙虎斗好复杂的模拟，为介绍清楚背景，CCF花了好多心思啊 不开$long$ $long$会后悔一生的！ 考场上其实我是A了这道题的，但是莫名其妙洛谷只给了我80 考试源代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;using namespace std;long long n,m,p1,p2,s1,s2,sum,minn=2000000000;long long c[100010];long long tiger,dragon;long long abs(long long a)&#123; if(a&lt;0) return -a; else return a;&#125;int main()&#123; //freopen(\"fight.in\",\"r\",stdin); //freopen(\"fight.out\",\"w\",stdout); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;c[i]); scanf(\"%d %d %d %d\",&amp;m,&amp;p1,&amp;s1,&amp;s2); c[p1]+=s1; for(int i=1;i&lt;=m-1;i++) dragon+=(m-i)*c[i]; for(int i=n;i&gt;=m+1;i--) tiger+=(i-m)*c[i]; for(int i=1;i&lt;=n;i++) &#123; if(i&lt;=m) sum=abs(dragon+s2*(m-i)-tiger); else if(i&gt;m) sum=abs(tiger+s2*(i-m)-dragon); if(sum&lt;minn) &#123; minn=sum; p2=i; &#125; else if(sum==minn &amp;&amp; i&lt;=p2) &#123; p2=i; &#125; &#125; printf(\"%d\",p2); return 0;&#125; T3 摆渡车这是道dp题，刚出考场的我就意识到了这一点 可是考场上我却打的是个模拟 在$1$~$m$之间枚举车子出发的时间 于是我们得到了一个$O(m\\times max\\sum\\limits_{i=1}^{n}t_i+n)$的算法： 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int n,m,maxn=-99999;int t[4000010];long long ans=999999999;int main()&#123; //freopen(\"bus.in\",\"r\",stdin); //freopen(\"bus.out\",\"w\",stdout); scanf(\"%d %d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; int tim; scanf(\"%d\",&amp;tim); t[tim]++; if(tim&gt;maxn) maxn=tim; &#125; for(int i=0;i&lt;m;i++) &#123; long long tot=0; for(int j=0;j&lt;=maxn;j++) if(t[j]&gt;0) tot+=(m+i-j%m)%m; if(tot&lt;ans) ans=tot; &#125; printf(\"%d\",ans); return 0;&#125; 然而只得了10分。希望有$dalao$能指出错误 T4 对称二叉树当时时间不多了，再加上本来就没想着要得多少分，果断地放弃了正解，而是准备拿前三个测试点 然而事与愿违，我只拿到了前两个测试点得分 普及总分218，（在我们省）还算可以吧 这是我第一次也是最后一次参加普及组，以后要在提高组里被人虐啦！ Day 2T1 旅行dfs裸搜 感觉可以得 50，因为我自己造了几组m=n-1的数据，然而只得了20 感觉还是特判没有判干净吧。 T2 填数游戏考场上手算了几组数据，然而却CE了 原因竟是 1rand() 在#include &lt;cstdlib&gt; 里 这导致我偷鸡不成蚀把米，要记住，下次可不能犯这样的错误啊！本可以在拿15分的。 T3 保卫王国 这道题完全没思路，不说了。 人生中的第一次NOIP就这么过去了，我懂得了许多： 练好基本功，搜索、模拟不能落下 要多熟悉各种基本算法 要多做历年的NOIP真题 NOIP，我们明年再见！","categories":[{"name":"杂笔","slug":"杂笔","permalink":"https://leverimmy.top/categories/%E6%9D%82%E7%AC%94/"},{"name":"游记","slug":"杂笔/游记","permalink":"https://leverimmy.top/categories/%E6%9D%82%E7%AC%94/%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"NOIP2018","slug":"NOIP2018","permalink":"https://leverimmy.top/tags/NOIP2018/"}]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"学习笔记/字符串","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"题解","slug":"题解","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/"},{"name":"CodeForces","slug":"题解/CodeForces","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/CodeForces/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"杂笔","slug":"杂笔","permalink":"https://leverimmy.top/categories/%E6%9D%82%E7%AC%94/"},{"name":"游记","slug":"杂笔/游记","permalink":"https://leverimmy.top/categories/%E6%9D%82%E7%AC%94/%E6%B8%B8%E8%AE%B0/"},{"name":"数论","slug":"学习笔记/数论","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/"},{"name":"杂项","slug":"学习笔记/杂项","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9D%82%E9%A1%B9/"},{"name":"动态规划","slug":"学习笔记/动态规划","permalink":"https://leverimmy.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"洛谷","slug":"题解/洛谷","permalink":"https://leverimmy.top/categories/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/"},{"name":"文化课","slug":"文化课","permalink":"https://leverimmy.top/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"数学","slug":"文化课/数学","permalink":"https://leverimmy.top/categories/%E6%96%87%E5%8C%96%E8%AF%BE/%E6%95%B0%E5%AD%A6/"},{"name":"备忘录","slug":"备忘录","permalink":"https://leverimmy.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"},{"name":"计划","slug":"备忘录/计划","permalink":"https://leverimmy.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/%E8%AE%A1%E5%88%92/"},{"name":"备忘录","slug":"杂笔/备忘录","permalink":"https://leverimmy.top/categories/%E6%9D%82%E7%AC%94/%E5%A4%87%E5%BF%98%E5%BD%95/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://leverimmy.top/tags/KMP/"},{"name":"前缀函数","slug":"前缀函数","permalink":"https://leverimmy.top/tags/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0/"},{"name":"贪心","slug":"贪心","permalink":"https://leverimmy.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"排序","slug":"排序","permalink":"https://leverimmy.top/tags/%E6%8E%92%E5%BA%8F/"},{"name":"回文树","slug":"回文树","permalink":"https://leverimmy.top/tags/%E5%9B%9E%E6%96%87%E6%A0%91/"},{"name":"组合数学","slug":"组合数学","permalink":"https://leverimmy.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"快速幂","slug":"快速幂","permalink":"https://leverimmy.top/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"容斥","slug":"容斥","permalink":"https://leverimmy.top/tags/%E5%AE%B9%E6%96%A5/"},{"name":"HBOI2020","slug":"HBOI2020","permalink":"https://leverimmy.top/tags/HBOI2020/"},{"name":"递归","slug":"递归","permalink":"https://leverimmy.top/tags/%E9%80%92%E5%BD%92/"},{"name":"类欧几里德算法","slug":"类欧几里德算法","permalink":"https://leverimmy.top/tags/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95/"},{"name":"高精度","slug":"高精度","permalink":"https://leverimmy.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"分治","slug":"分治","permalink":"https://leverimmy.top/tags/%E5%88%86%E6%B2%BB/"},{"name":"技巧","slug":"技巧","permalink":"https://leverimmy.top/tags/%E6%8A%80%E5%B7%A7/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leverimmy.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"费用流","slug":"费用流","permalink":"https://leverimmy.top/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"网络流 24 题","slug":"网络流-24-题","permalink":"https://leverimmy.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-24-%E9%A2%98/"},{"name":"最短路","slug":"最短路","permalink":"https://leverimmy.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"数学","slug":"数学","permalink":"https://leverimmy.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数列","slug":"数列","permalink":"https://leverimmy.top/tags/%E6%95%B0%E5%88%97/"},{"name":"前缀和","slug":"前缀和","permalink":"https://leverimmy.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"差分","slug":"差分","permalink":"https://leverimmy.top/tags/%E5%B7%AE%E5%88%86/"},{"name":"生活","slug":"生活","permalink":"https://leverimmy.top/tags/%E7%94%9F%E6%B4%BB/"},{"name":"字符串","slug":"字符串","permalink":"https://leverimmy.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"网络流","slug":"网络流","permalink":"https://leverimmy.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最大流","slug":"最大流","permalink":"https://leverimmy.top/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"Dinic","slug":"Dinic","permalink":"https://leverimmy.top/tags/Dinic/"},{"name":"计数","slug":"计数","permalink":"https://leverimmy.top/tags/%E8%AE%A1%E6%95%B0/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://leverimmy.top/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"等比数列","slug":"等比数列","permalink":"https://leverimmy.top/tags/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97/"},{"name":"CSP2019S","slug":"CSP2019S","permalink":"https://leverimmy.top/tags/CSP2019S/"},{"name":"LaTeX","slug":"LaTeX","permalink":"https://leverimmy.top/tags/LaTeX/"},{"name":"DLX","slug":"DLX","permalink":"https://leverimmy.top/tags/DLX/"},{"name":"搜索","slug":"搜索","permalink":"https://leverimmy.top/tags/%E6%90%9C%E7%B4%A2/"},{"name":"NOIP2018","slug":"NOIP2018","permalink":"https://leverimmy.top/tags/NOIP2018/"}]}